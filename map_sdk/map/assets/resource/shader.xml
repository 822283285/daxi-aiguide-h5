<Xml>
    <effect name="CommonRender">
        <!--InputLayout-->
        <inputLayout name="FVFXyz">
            <attribute name="position" semantic="position" index="0"/>
        </inputLayout>
        <inputLayout name="FVFXyzDiffuse">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="color" semantic="color" index="0" offset="12"/>
        </inputLayout>
        <inputLayout name="FVFXyzTex">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="12"/>
        </inputLayout>
        <inputLayout name="FVFXyzTex2">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="12"/>
            <attribute name="texcoord2" semantic="texcoord" index="1" offset="20"/>
        </inputLayout>
        <inputLayout name="FVFXyzwTex">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="16"/>
        </inputLayout>
        <inputLayout name="FVFXyzwTex2">
            <attribute name="Position" semantic="position" index="0"/>
            <attribute name="UV" semantic="texcoord" index="0" offset="16"/>
            <attribute name="UV2" semantic="texcoord" index="1" offset="24"/>
        </inputLayout>
        <inputLayout name="FVFXyzw">
            <attribute name="position" semantic="position" index="0"/>
        </inputLayout>
        <inputLayout name="FVFXyzDiffuseTex">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="color" semantic="color" index="0" offset="12"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="16"/>
        </inputLayout>
        <inputLayout name="FVFXyzTexDiffuse">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="12"/>
            <attribute name="color" semantic="color" index="0" offset="20"/>
        </inputLayout>
        <inputLayout name="FVFXyzNormal">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="normal" semantic="normal" index="0" offset="12"/>
        </inputLayout>
        <inputLayout name="FVFXyzNormalTex">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="normal" semantic="normal" index="0" offset="12"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="24"/>
        </inputLayout>
        <inputLayout name="FVFXyzNormal2Tex">
            <attribute name="position" semantic="position" index="0"/>
            <attribute name="normal" semantic="normal" index="0" offset="12"/>
            <attribute name="normal2" semantic="normal" index="1" offset="24"/>
            <attribute name="texcoord" semantic="texcoord" index="0" offset="36"/>
        </inputLayout>
        <inputLayout name="FVFFontRenderWithBlur">
            <attribute name="a_pos_offset" semantic="position" index="0"/>
            <attribute name="a_data" semantic="normal" index="0" offset="8"/>
            <attribute name="a_halo_color" semantic="normal" index="0" offset="16"/>
            <attribute name="a_projected_pos" semantic="texcoord" index="0" offset="24"/>
            <attribute name="a_fade_opacity" semantic="texcoord" index="0" offset="36"/>
            <attribute name="a_fill_color" semantic="texcoord" index="0" offset="40"/>
            <attribute name="a_halo_width" semantic="texcoord" index="0" offset="48"/>
        </inputLayout>
        <!--Universe Shader-->
        <shaderParameter name="vs_universe">
            <shaderParameter name="vs_model">
                <parameter name="uMVMatrix" type="mat4" count="1"/>
                <parameter name="uPMatrix" type="mat4" count="1"/>
                <parameter name="uFrustum" type="vec4" count="1"/>
            </shaderParameter>
        </shaderParameter>
        <shader name="vs_universe" type="vertex_shader" input="FVFXyz" language="glsl">
            <![CDATA[
                attribute vec3 position;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                uniform vec4 uFrustum;

                varying vec3 v_texCoord;

                void main()
                {
                  gl_Position = uPMatrix * uMVMatrix * vec4(uFrustum.x * position, 1.0);
                  v_texCoord = position.xyz;
                }
            ]]>
        </shader>
        <shaderParameter name="ps_universe">
            <parameter name="uSampler" type="textureCube" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_universe" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform samplerCube uSampler;
        varying vec3 v_texCoord;

        void main()
        {
            vec3 rgb = textureCube(uSampler, normalize(v_texCoord)).rgb;
            gl_FragColor = vec4(rgb, 1.0);
            //gl_FragColor = vec4(1.0,1.0,1.0, 1.0);
        }
      ]]>
        </shader>

        <!--Canvas Shader-->
        <shaderParameter name="vs_canvas">
            <parameter name="uMvpMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_canvas" type="vertex_shader" input="FVFXyzTex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec2 texcoord;
        //attribute vec4 color;

        uniform mat4 uMvpMatrix;

        varying vec2 vTextureCoord;
        //varying vec4 vColor;

        void main(void) 
        {
          gl_Position = uMvpMatrix * vec4(position, 1.0);
          vTextureCoord = texcoord;
          //vColor = color;
        }
       ]]>
        </shader>


        <shaderParameter name="ps_canvas">
            <parameter name="vColor" type="vec4" count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_canvas" type="pixel_shader" language="glsl">
             <![CDATA[
                precision mediump float;
                varying vec2 vTextureCoord;
               //varying vec4 vColor;

                uniform vec4 vColor;
                uniform sampler2D uSampler;

                void main(void) 
                {
                    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * vColor;
                }
              ]]>
        </shader>

     <!--    <shaderParameter name="vs_text_with_blur">
            <parameter name="u_matrix" type="mat4" count="1"/>
            <parameter name="u_label_plane_matrix" type="mat4" count="1"/>
            <parameter name="u_gl_coord_matrix" type="mat4" count="1"/>

            <parameter name="u_texsize" type="vec2" count="1"/>

            <parameter name="u_size_t" type="float" count="1"/>
            <parameter name="u_size" type="float" count="1"/>
            <parameter name="u_aspect_ratio" type="float" count="1"/>
            <parameter name="u_camera_to_center_distance" type="float" count="1"/>

            <parameter name="a_fill_color_t" type="float" count="1"/>
            <parameter name="a_halo_color_t" type="float" count="1"/>
            <parameter name="a_halo_width_t" type="float" count="1"/>

            <parameter name="u_opacity" type="float" count="1"/>
            <parameter name="u_halo_blur" type="float" count="1"/>
            <parameter name="u_height" type="float" count="1"/>

            <parameter name="u_fade_change" type="float" count="1"/>

            <parameter name="u_is_size_zoom_constant" type="bool" count="1"/>
            <parameter name="u_is_size_feature_constant" type="bool" count="1"/>
            <parameter name="u_is_text" type="bool" count="1"/>
            <parameter name="u_pitch_with_map" type="bool" count="1"/>
            <parameter name="u_rotate_symbol" type="bool" count="1"/>
        </shaderParameter>
        <shader name="vs_text_with_blur" type="vertex_shader" input="FVFFontRenderWithBlur" language="glsl">
            <![CDATA[
                #define DEVICE_PIXEL_RATIO 2.0
                #ifdef GL_ES
                precision highp float;
                #else
                 
                #if !defined(lowp)
                #define lowp
                #endif
                 
                #if !defined(mediump)
                #define mediump
                #endif
                 
                #if !defined(highp)
                #define highp
                #endif
                 
                #endif
            
                vec2 unpack_float(const float packedValue) {
                    int packedIntValue = int(packedValue);
                    int v0 = packedIntValue / 256;
                    return vec2(v0, packedIntValue - v0 * 256);
                }
                 
                vec2 unpack_opacity(const float packedOpacity) {
                    int intOpacity = int(packedOpacity) / 2;
                    return vec2(float(intOpacity) / 127.0, mod(packedOpacity, 2.0));
                }
                 
                vec4 decode_color(const vec2 encodedColor) {
                    return vec4(
                        unpack_float(encodedColor[0]) / 255.0,
                        unpack_float(encodedColor[1]) / 255.0
                    );
                }
                 
                // Unpack a pair of paint values and interpolate between them.
                float unpack_mix_vec2(const vec2 packedValue, const float t) {
                    return mix(packedValue[0], packedValue[1], t);
                }
                 
                // Unpack a pair of paint values and interpolate between them.
                vec4 unpack_mix_vec4(const vec4 packedColors, const float t) {
                    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));
                    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));
                    return mix(minColor, maxColor, t);
                }
                 
                vec2 get_pattern_pos(const vec2 pixel_coord_upper, const vec2 pixel_coord_lower,
                    const vec2 pattern_size, const float tile_units_to_pixels, const vec2 pos) {
                 
                    vec2 offset = mod(mod(mod(pixel_coord_upper, pattern_size) * 256.0, pattern_size) * 256.0 + pixel_coord_lower, pattern_size);
                    return (tile_units_to_pixels * pos + offset) / pattern_size;
                }
                 
                 
                const float PI = 3.141592653589793;
                 
                attribute vec4 a_pos_offset;
                attribute vec4 a_data;
                attribute vec3 a_projected_pos;
                attribute float a_fade_opacity;
                attribute highp vec4 a_fill_color;
                attribute highp vec4 a_halo_color;
                attribute lowp vec2 a_halo_width;


                uniform mat4 u_matrix;  
                uniform mat4 u_label_plane_matrix;
                uniform mat4 u_gl_coord_matrix;

                uniform vec2 u_texsize;

                uniform highp float u_size_t; // used to interpolate between zoom stops when size is a composite function
                uniform highp float u_size; // used when size is both zoom and feature constant
                // uniform highp float u_pitch;
                uniform highp float u_aspect_ratio;
                uniform highp float u_camera_to_center_distance;

                uniform lowp float a_fill_color_t;
                uniform lowp float a_halo_color_t;
                uniform lowp float a_halo_width_t;

                uniform lowp float u_opacity;
                uniform lowp float u_halo_blur;
                uniform lowp float u_height;

                uniform float u_fade_change;

                 
                uniform bool u_is_size_zoom_constant;
                uniform bool u_is_size_feature_constant;
                uniform bool u_is_text;
                uniform bool u_pitch_with_map;
                uniform bool u_rotate_symbol;


                varying highp vec4 fill_color;
                varying lowp float halo_width;
                varying highp vec4 halo_color;
                varying vec2 v_data0;
                varying vec3 v_data1;       
                 

                void main() {
                    fill_color = unpack_mix_vec4(a_fill_color, a_fill_color_t);
                    halo_color = unpack_mix_vec4(a_halo_color, a_halo_color_t);
                    halo_width = unpack_mix_vec2(a_halo_width, a_halo_width_t);

                    lowp float opacity = u_opacity;
                    lowp float halo_blur = u_halo_blur;
                    lowp float height = u_height;
                  
                    vec2 a_pos = a_pos_offset.xy;
                    vec2 a_offset = a_pos_offset.zw;
                 
                    vec2 a_tex = a_data.xy;
                    vec2 a_size = a_data.zw;
                 
                    highp float segment_angle = -a_projected_pos[2];
                    float size;
                 
                    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {
                        size = mix(a_size[0], a_size[1], u_size_t) / 10.0;
                    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {
                        size = a_size[0] / 10.0;
                    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {
                        size = u_size;
                    } else {
                        size = u_size;
                    }
                 
                    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);
                    highp float camera_to_anchor_distance = projectedPoint.w;
                    highp float distance_ratio = u_pitch_with_map ?
                        camera_to_anchor_distance / u_camera_to_center_distance :
                        u_camera_to_center_distance / camera_to_anchor_distance;
                    highp float perspective_ratio = 0.5 + 0.5 * distance_ratio;
                 
                    size *= perspective_ratio;
                 
                    float fontScale = u_is_text ? size / 24.0 : size;
                 
                    highp float symbol_rotation = 0.0;
                    if (u_rotate_symbol) {
                        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);
                 
                        vec2 a = projectedPoint.xy / projectedPoint.w;
                        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;
                 
                        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);
                    }
                 
                    highp float angle_sin = sin(segment_angle + symbol_rotation);
                    highp float angle_cos = cos(segment_angle + symbol_rotation);
                    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);
                 
                    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, height, 1.0);
                    //gl_Position = u_gl_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 64.0 * fontScale), 0.0, 1.0);
                    gl_Position = u_gl_coord_matrix * vec4(a_pos_offset.xy, 1.0, 1.0);
                    float gamma_scale = gl_Position.w;
                 
                    vec2 tex = a_tex / u_texsize;
                    vec2 fade_opacity = unpack_opacity(a_fade_opacity);
                    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;
                    float interpolated_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));
                 
                    v_data0 = vec2(tex.x, tex.y);
                    v_data1 = vec3(gamma_scale, size, interpolated_fade_opacity);
                }
            ]]>
        </shader>

        <shaderParameter name="ps_text_with_blur">
            <parameter name="u_is_halo" type="bool" count="1"/>
            <parameter name="u_gamma_scale" type="float" count="1"/>
            <parameter name="u_texture" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_text_with_blur" type="pixel_shader" language="glsl">
            <![CDATA[
                #define DEVICE_PIXEL_RATIO 2.0
                #ifdef GL_ES
                precision mediump float;
                #else
                 
                #if !defined(lowp)
                #define lowp
                #endif
                 
                #if !defined(mediump)
                #define mediump
                #endif
                 
                #if !defined(highp)
                #define highp
                #endif
                 
                #endif
                 
                #define SDF_PX 8.0
                #define EDGE_GAMMA 0.105/DEVICE_PIXEL_RATIO
                 

                varying highp vec4 fill_color;
                varying highp vec4 halo_color;
                varying lowp float halo_width;
                varying vec2 v_data0;
                varying vec3 v_data1;

                uniform lowp float u_opacity;
                uniform lowp float u_halo_blur;
                uniform lowp float u_height;

                uniform highp float u_gamma_scale;

                uniform bool u_is_text;
                uniform bool u_is_halo;

                uniform sampler2D u_texture;

                void main() {
                     
                    lowp float opacity = u_opacity;
                    lowp float halo_blur = u_halo_blur;
                    lowp float height = u_height;

                    vec2 tex = v_data0.xy;
                    float gamma_scale = v_data1.x;
                    float size = v_data1.y;
                    float fade_opacity = v_data1[2];
                 
                    float fontScale = u_is_text ? size / 24.0 : size;
                 
                    lowp vec4 color = fill_color;
                    highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);
                    lowp float buff = (256.0 - 64.0) / 256.0;
                    if (u_is_halo) {
                        color = halo_color;
                        gamma = (halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);
                        buff = (6.0 - halo_width / fontScale) / SDF_PX;
                    }
                 
                    lowp float dist = texture2D(u_texture, tex).a;
                    highp float gamma_scaled = gamma * gamma_scale;
                    highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);
                 
                    gl_FragColor = color * (alpha * opacity * fade_opacity) + vec4(1,1,1,1);
                     gl_FragColor = vec4(1,1,1,1);
                }
            ]]>
        </shader> -->




        <!--Compass Shader-->
        <shaderParameter name="vs_compass">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="uLineWidth" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_compass" type="vertex_shader" input="FVFXyzNormal2Tex" language="glsl">
            <![CDATA[
                attribute vec3 position;
                attribute vec3 normal;
                attribute vec3 normal2;
                attribute vec2 texcoord;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                uniform vec4 uLineWidth;

                varying vec4 vTextureCoord;

                void main()
                {
                  if ( texcoord.s < 0.0) {
                      vTextureCoord.t = 1.0;
                  } else {
                      vTextureCoord.t = 0.0;
                  }

                  vTextureCoord.s = texcoord.t;

                  vec3 pos = position + normal * texcoord.s * uLineWidth.x;
                  gl_Position = uPMatrix * uMVMatrix * vec4(pos, 1.0);
                  vTextureCoord.p =uLineWidth.z;
                  vTextureCoord.q =uLineWidth.w;
                }
           ]]>
        </shader>
        <shaderParameter name="ps_compass">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_compass" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                varying vec4 vTextureCoord;

                uniform sampler2D uSampler;
                uniform vec4 uBlendColor;

                void main(void)
                {
                    if(vTextureCoord.s < vTextureCoord.p || vTextureCoord.s > vTextureCoord.q)
                    {
                            discard;
                    }
                  gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * uBlendColor;
                }
            ]]>
        </shader>

        <shaderParameter name="vs_text_with_blur">
            <parameter name="uMvpMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_text_with_blur" type="vertex_shader" input="FVFXyzTexDiffuse" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec2 texcoord;
        attribute vec4 color;

        uniform mat4 uMvpMatrix;

        //varying vec2 vTextureCoord;
        //varying vec4 vColor;

        vec2 unpack_opacity(const float packedOpacity) {
            int intOpacity = int(packedOpacity) / 2;
            return vec2(float(intOpacity) / 127.0, mod(packedOpacity, 2.0));
        }
        varying vec2 v_data0;
        varying vec3 v_data1;
        void main(void) 
        {
            gl_Position = uMvpMatrix * vec4(position, 1.0);
            //vTextureCoord = texcoord;

            float a_fade_opacity = 129.0;
            float u_fade_change = 1.167;
            vec2 fade_opacity = unpack_opacity(a_fade_opacity);

            float gamma_scale = 1.0;
            float size = 13.0;
            float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;
            float interpolated_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));
                 
            v_data0 = texcoord;//vec2(tex.x, tex.y);
            v_data1 = vec3(color.w, size, interpolated_fade_opacity);



          //vColor = color;
        }
       ]]>
        </shader>

        <shaderParameter name="ps_text_with_blur">
            <parameter name="vColor" type="vec4" count="1"/>
             <parameter name="u_is_halo" type="bool" count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_text_with_blur" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                //varying vec2 vTextureCoord;
               //varying vec4 vColor;

                uniform vec4 vColor;
                uniform bool u_is_halo;
                uniform sampler2D uSampler;

                varying vec2 v_data0;
                varying vec3 v_data1;

                #ifdef GL_ES
                precision highp float;
                #else
                 
                #if !defined(lowp)
                #define lowp
                #endif
                 
                #if !defined(mediump)
                #define mediump
                #endif
                 
                #if !defined(highp)
                #define highp
                #endif
                 
                #endif
                #define DEVICE_PIXEL_RATIO 2.0
                #define SDF_PX 8.0
                #define EDGE_GAMMA 0.105/DEVICE_PIXEL_RATIO

                void main(void) 
                {
                    float size = v_data1.y;
                    float fontScale = size / 24.0;
                    
                    float u_gamma_scale = 1.0;
                    lowp float opacity = v_data1.x;//1.0;
                    lowp float halo_blur = 0.0;
                    lowp float height = 16.0;

                    vec2 tex = v_data0;

                    float halo_width = 1.3;//29912.0/65535.0;

                    vec4 halo_color = vec4(1.0,1.0,1.0,1.0);
                    //vec4 halo_blur  = vec4(1.0,1.0,1.0,1.0); 

                    highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);
                    lowp float buff = (256.0 - 64.0) / 256.0;

                    float gamma_scale = v_data1.x;

                    float fade_opacity = v_data1[2];


                    //float gamma_scale = 0.01;

                    lowp vec4 color = vColor;;
                    if (u_is_halo) {
                        color = halo_color;
                        gamma = (halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);
                        buff = (6.0 - halo_width / fontScale) / SDF_PX;
                    }
                 
                    lowp float dist = texture2D(uSampler, tex).a;
                    highp float gamma_scaled = gamma * gamma_scale;
                    highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);

                 
                    gl_FragColor = color;
                    gl_FragColor.a = color.a * (alpha * opacity * fade_opacity);
                    //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * vColor;
                }
              ]]>
        </shader>




        





        <!--SkyFromAtmosphere Shader-->
        <shaderParameter name="vs_sky_atmosphere">
            <parameter name="g_WorldViewProj" type="mat4" count="1"/>
            <parameter name="g_v3CameraPos" type="vec4" count="1"/>
            <parameter name="g_v3LightPos" type="vec4" count="1"/>
            <parameter name="g_cameraHeight" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_sky_atmosphere" type="vertex_shader" input="FVFXyz" language="glsl">
            <![CDATA[
                uniform mat4 g_WorldViewProj;
                uniform vec4 g_v3CameraPos;
                uniform vec4 g_v3LightPos;
                uniform vec4 g_cameraHeight;

                #define red_wave 5.6020447
                #define green_wave 9.4732844
                #define blue_wave 19.6438026
                #define fInnerRadius 6378137.0
                #define fOuterRadius (fInnerRadius * 1.01)
                #define fOuterRadius2 (fOuterRadius * fOuterRadius)
                #define ESun 20.0
                #define Kr 0.0025
                #define Km 0.0015
                #define fKrESun (Kr*ESun)
                #define fKmESun (Km*ESun)
                #define fKr4PI 0.03141593
                #define fKm4PI 0.0188495573
                #define fScale (1.0/(fOuterRadius - fInnerRadius))
                #define fScaleDepth 0.25
                #define fScaleOverScaleDepth (fScale/fScaleDepth)
                #define nSamples 2
                #define fSamples 2.0

                attribute vec3 position;
                //attribute vec2 texcoord;

                //varying vec2 outTexcoord;
                varying vec3 direction;
                varying vec3 outColor;
                varying vec3 secondaryColor;

                float scale(float fCos)
                {
                  float x = 1.0 - fCos;
                  return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
                }

                void main()
                {
                  vec3 v3Pos = position.xyz;
                  vec3 cameraPos = g_v3CameraPos.xyz;
                  vec3 light = g_v3LightPos.xyz;

                  // Get the ray from the camera to the vertex, and its length (which is the far point of the ray passing through the atmosphere)
                  vec3 v3Ray = v3Pos - cameraPos;
                  float fFar = length(v3Ray);
                  v3Ray /= fFar;

                  // Calculate the ray's starting position, then calculate its scattering offset
                  vec3 v3Start = cameraPos;
                  float fHeight = length(v3Start);
                  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - g_cameraHeight.x));
                  float fStartAngle = dot(v3Ray, v3Start) / fHeight;
                  float fStartOffset = fDepth*scale(fStartAngle);

                  // Initialize the scattering loop variables
                  //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);
                  float fSampleLength = fFar / fSamples;
                  float fScaledLength = fSampleLength * fScale;
                  vec3 v3SampleRay = v3Ray * fSampleLength;
                  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

                  // Now loop through the sample rays
                  vec3 v3InvWavelength = vec3(red_wave, green_wave, blue_wave);
                  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
                  for(int i=0; i<nSamples; i++)
                  {
                    float fHeight = length(v3SamplePoint);
                    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
                    float fLightAngle = dot(light, v3SamplePoint) / fHeight;
                    float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;
                    float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));
                    vec3 v3Attenuate = vec3(exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI)));
                    v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
                    v3SamplePoint += v3SampleRay;
                  }

                  // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
                  gl_Position = g_WorldViewProj * vec4(position, 1.0);
                  //outTexcoord = vec2(texcoord.x,1.0-texcoord.y);
                  gl_Position.z = gl_Position.w * 0.999995;
                  direction = cameraPos - v3Pos;
                  secondaryColor = v3FrontColor * fKmESun;
                  outColor = v3FrontColor * (v3InvWavelength * fKrESun);
                }
              ]]>
        </shader>

        <shaderParameter name="ps_sky_atmosphere">
            <parameter name="g_v3LightPosP" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_sky_atmosphere" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;

        #define g (-0.95)
        #define g2 (g*g)

        uniform vec4 g_v3LightPosP;
        //uniform sampler2D diffuseSampler;

        //varying vec2 outTexcoord;
        varying vec3 direction;
        varying vec3 outColor;
        varying vec3 secondaryColor;

        void main()
        {
          vec3 light = g_v3LightPosP.xyz;
          float fCos = dot(light, direction) / length(direction);
          float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);
          float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);
          vec3 f = fRayleighPhase * outColor + fMiePhase * secondaryColor;
          vec4 color = vec4(f.x, f.y, f.z, 1.0);
          //vec4 color = vec4(1.0, 1.0, 1.0, 1.0);
          float lum = color.x*0.299 + color.y * 0.587+ color.z*0.114;
          //gl_FragColor = color * mix(vec4(1.0,1.0,1.0,1.0), texture2D(diffuseSampler, outTexcoord), g_v3LightPosP.w);
          gl_FragColor = color;
        }
      ]]>
        </shader>

        <!--SkyFromSpace Shader-->
        <shaderParameter name="vs_sky_space">
            <parameter name="g_WorldViewProj" type="mat4" count="1"/>
            <parameter name="g_v3CameraPos" type="vec4" count="1"/>
            <parameter name="g_v3LightPos" type="vec4" count="1"/>
            <parameter name="g_cameraHeight2" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_sky_space" type="vertex_shader" input="FVFXyz" language="glsl">
            <![CDATA[
        uniform mat4 g_WorldViewProj;
        uniform vec4 g_v3CameraPos;
        uniform vec4 g_v3LightPos;
        uniform vec4 g_cameraHeight2;

        #define red_wave 5.6020447
        #define green_wave 9.4732844
        #define blue_wave 19.6438026
        #define fInnerRadius 6378137.0
        #define fOuterRadius (fInnerRadius * 1.01)
        #define fOuterRadius2 (fOuterRadius * fOuterRadius)
        #define ESun 20.0
        #define Kr 0.0025
        #define Km 0.0015
        #define fKrESun (Kr*ESun)
        #define fKmESun (Km*ESun)
        #define fKr4PI 0.03141593
        #define fKm4PI 0.0188495573
        #define fScale (1.0/(fOuterRadius - fInnerRadius))
        #define fScaleDepth 0.25
        #define fScaleOverScaleDepth (fScale/fScaleDepth)
        #define nSamples 2
        #define fSamples 2.0

        attribute vec3 position;
        //attribute vec2 texture;

        varying vec3 direction;
        varying vec3 outColor;
        varying vec3 secondaryColor;


        float scale(float fCos)
        {
            float x = 1.0 - fCos;
            return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
        }

        void main()
        {
            vec3 v3Pos = position.xyz;
            vec3 cameraPos = g_v3CameraPos.xyz;
            vec3 light = g_v3LightPos.xyz;

            vec3 v3Ray = v3Pos - cameraPos;
            float fFar = length(v3Ray);
            v3Ray /= fFar;

            float B = 2.0 * dot(cameraPos, v3Ray);
            float C = g_cameraHeight2.x - fOuterRadius2;
            float fDet = max(0.0, B*B - 4.0 * C);
            float fNear = 0.5 * (-B - sqrt(fDet));

            // Calculate the ray's starting position, then calculate its scattering offset
            vec3 v3Start = cameraPos + v3Ray * fNear;
            fFar -= fNear;
            float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;
            float fStartDepth = exp(-1.0 / fScaleDepth);
            float fStartOffset = fStartDepth*scale(fStartAngle);

            // Initialize the scattering loop variables
            //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);
            float fSampleLength = fFar / fSamples;
            float fScaledLength = fSampleLength * fScale;
            vec3 v3SampleRay = v3Ray * fSampleLength;
            vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

            // Now loop through the sample rays
            vec3 v3InvWavelength = vec3(red_wave, green_wave, blue_wave);
            vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);
            for(int i=0; i<nSamples; i++)
            {
                float fHeight = length(v3SamplePoint);
                float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
                float fLightAngle = dot(light, v3SamplePoint) / fHeight;
                float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;
                float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));
                vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));
                v3FrontColor += v3Attenuate * (fDepth * fScaledLength);
                v3SamplePoint += v3SampleRay;
            }

            // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
            gl_Position = g_WorldViewProj * vec4(position, 1.0);
            //gl_Position.z = gl_Position.w;
            direction = cameraPos - v3Pos;
            secondaryColor = v3FrontColor * fKmESun;
            outColor = v3FrontColor * (v3InvWavelength * fKrESun);
        }
      ]]>
        </shader>

        <shaderParameter name="ps_sky_space">
            <parameter name="g_v3LightPosP" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_sky_space" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 g_v3LightPosP;

        #define g (-0.95)
        #define g2 (g*g)

        varying vec3 direction;
        varying vec3 outColor;
        varying vec3 secondaryColor;

        void main()
        {
          vec3 light = g_v3LightPosP.xyz;
          float fCos = dot(light, direction) / length(direction);
          float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);
          float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);
          vec3 f = fRayleighPhase * outColor + fMiePhase * secondaryColor;
          vec4 color = vec4(f.x, f.y, f.z, 1.0);
          //vec4 color = vec4(1.0, 1.0, 1.0, 1.0);
          float lum = color.x*0.299 + color.y * 0.587+ color.z*0.114;
          gl_FragColor = color;
        }
      ]]>
        </shader>


        <!--Terrain Shader-->
        <shaderParameter name="vs_terrain">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <!--<parameter name="uTexMatrix" type="mat4" count="1"/>-->
            <parameter name="uGlobePos" type="vec4" count="1"/>
            <parameter name="uAtmosphere" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_terrain" type="vertex_shader" input="FVFXyzTex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec2 texcoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
      //  uniform mat4 uTexMatrix;
        uniform vec4 uGlobePos;
        uniform vec4 uAtmosphere;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
        varying float vAtmosphere;

        void main(void)
        {
              vec3 uGlobePosition = vec3(uGlobePos.x,uGlobePos.y,uGlobePos.z);
              float uAtmosphereRadius = uAtmosphere.x;
              float uAtmosphereScale = uAtmosphere.y;

              vAtmosphere = 0.0;
              float scale = 10.0 / 6378137.0;

             vec4 pos = vec4(position, 1.0);
             vec4 cPos4 = uMVMatrix * pos;
             vec3 ray = vec3(cPos4.x * scale,cPos4.y * scale,cPos4.z * scale);
             float c = dot(uGlobePosition,uGlobePosition)-(uAtmosphereRadius*uAtmosphereRadius);
             float a = 2.0*dot(ray,ray);
             float b = 2.0*dot(uGlobePosition,ray);


            if (c > 0.0) {
                // outside atmosphere
                float d = b*b - 2.0*a*c;
                if (d < 0.0) {
                    vAtmosphere = 0.0;
                } else {
                    // d = 2.0*sqrt(d)/a; // for outside corona
                    d = (b - sqrt(d))/a;
                    float gradient = (uAtmosphereRadius - length(ray*(1.0+d)*0.5 - uGlobePosition))*uAtmosphereScale;
                    vAtmosphere = length(ray*(1.0-d))*gradient; //0.0001
                }
            } else {
                // inside atmosphere
                float gradient = (uAtmosphereRadius - length(ray*0.5 - uGlobePosition))*uAtmosphereScale;
                vAtmosphere = length(ray)*gradient; //0.0001;
            }
            vAtmosphere = clamp(vAtmosphere*2.0,0.0,1.0);

          gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
          //vTextureCoord = aTextureCoord;
          //vec4 texCoord = vec4(texcoord.s, texcoord.t, 1.0, 0.0);
         // texCoord = uTexMatrix * texCoord;
          //vTextureCoord.s = texCoord.x;
          //vTextureCoord.t = texCoord.y;
          //vTextureCoord.s = texcoord.s;
          //vTextureCoord.t = texcoord.t;
          vTextureCoord = texcoord;

          vLightWeighting = vec3(1.0, 1.0, 1.0);
        }
      ]]>
        </shader>

        <shaderParameter name="ps_terrain_1">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_1" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
        varying float vAtmosphere;

        uniform sampler2D uSampler0;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            color = sampleAndBlend( color, uSampler0, clamp(vTextureCoord, 0.0, 1.0),  uTexExtent0,uTexTransform0, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>

        <shaderParameter name="ps_terrain_2">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_2" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
         varying float vAtmosphere;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>


        <shaderParameter name="ps_terrain_3">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uTexTransform2" type="vec4" count="1"/>
            <parameter name="uTexExtent2" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_3" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;
        uniform vec4 uTexTransform2;
        uniform vec4 uTexExtent2;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
        varying float vAtmosphere;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            color = sampleAndBlend( color, uSampler2, texcoords, uTexExtent2,uTexTransform2, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>

        <shaderParameter name="ps_terrain_4">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uTexTransform2" type="vec4" count="1"/>
            <parameter name="uTexExtent2" type="vec4" count="1"/>
            <parameter name="uTexTransform3" type="vec4" count="1"/>
            <parameter name="uTexExtent3" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler3" type="texture2d" index="3" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_4" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;
        uniform vec4 uTexTransform2;
        uniform vec4 uTexExtent2;
        uniform vec4 uTexTransform3;
        uniform vec4 uTexExtent3;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
        varying float vAtmosphere;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            color = sampleAndBlend( color, uSampler2, texcoords, uTexExtent2,uTexTransform2, textureAlpha );
            color = sampleAndBlend( color, uSampler3, texcoords, uTexExtent3,uTexTransform3, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;

            /*
            vec3 startDayColor = Computedaycolor(initialColor, clamp(v_textureCoordinates, 0.0, 1.0));

            vec2 translation = uTexTransform0.xy;
            vec2 scale = vec2(uTexTransform0.z, uTexTransform0.w);
            //translation.y *= uTexTransform0.w;

            vec2 vTextureCoordinate = vTextureCoord * scale + translation;

            vec4 textureColor = texture2D(uSampler, vec2(vTextureCoordinate.x, vTextureCoordinate.y));
            gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
            */
        }
      ]]>
        </shader>

        <shaderParameter name="ps_terrain_5">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uTexTransform2" type="vec4" count="1"/>
            <parameter name="uTexExtent2" type="vec4" count="1"/>
            <parameter name="uTexTransform3" type="vec4" count="1"/>
            <parameter name="uTexExtent3" type="vec4" count="1"/>
            <parameter name="uTexTransform4" type="vec4" count="1"/>
            <parameter name="uTexExtent4" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler3" type="texture2d" index="3" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler4" type="texture2d" index="4" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_5" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;
        uniform vec4 uTexTransform2;
        uniform vec4 uTexExtent2;
        uniform vec4 uTexTransform3;
        uniform vec4 uTexExtent3;
        uniform vec4 uTexTransform4;
        uniform vec4 uTexExtent4;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
        varying float vAtmosphere;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;
        uniform sampler2D uSampler4;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            color = sampleAndBlend( color, uSampler2, texcoords, uTexExtent2,uTexTransform2, textureAlpha );
            color = sampleAndBlend( color, uSampler3, texcoords, uTexExtent3,uTexTransform3, textureAlpha );
            color = sampleAndBlend( color, uSampler4, texcoords, uTexExtent4,uTexTransform4, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>
        <shaderParameter name="ps_terrain_6">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uTexTransform2" type="vec4" count="1"/>
            <parameter name="uTexExtent2" type="vec4" count="1"/>
            <parameter name="uTexTransform3" type="vec4" count="1"/>
            <parameter name="uTexExtent3" type="vec4" count="1"/>
            <parameter name="uTexTransform4" type="vec4" count="1"/>
            <parameter name="uTexExtent4" type="vec4" count="1"/>
            <parameter name="uTexTransform5" type="vec4" count="1"/>
            <parameter name="uTexExtent5" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler3" type="texture2d" index="3" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler4" type="texture2d" index="4" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler5" type="texture2d" index="5" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_6" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;
        uniform vec4 uTexTransform2;
        uniform vec4 uTexExtent2;
        uniform vec4 uTexTransform3;
        uniform vec4 uTexExtent3;
        uniform vec4 uTexTransform4;
        uniform vec4 uTexExtent4;
        uniform vec4 uTexTransform5;
        uniform vec4 uTexExtent5;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
         varying float vAtmosphere;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;
        uniform sampler2D uSampler4;
        uniform sampler2D uSampler5;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            color = sampleAndBlend( color, uSampler2, texcoords, uTexExtent2,uTexTransform2, textureAlpha );
            color = sampleAndBlend( color, uSampler3, texcoords, uTexExtent3,uTexTransform3, textureAlpha );
            color = sampleAndBlend( color, uSampler4, texcoords, uTexExtent4,uTexTransform4, textureAlpha );
            color = sampleAndBlend( color, uSampler5, texcoords, uTexExtent5,uTexTransform5, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

             float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>

        <shaderParameter name="ps_terrain_7">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uTexTransform2" type="vec4" count="1"/>
            <parameter name="uTexExtent2" type="vec4" count="1"/>
            <parameter name="uTexTransform3" type="vec4" count="1"/>
            <parameter name="uTexExtent3" type="vec4" count="1"/>
            <parameter name="uTexTransform4" type="vec4" count="1"/>
            <parameter name="uTexExtent4" type="vec4" count="1"/>
            <parameter name="uTexTransform5" type="vec4" count="1"/>
            <parameter name="uTexExtent5" type="vec4" count="1"/>
            <parameter name="uTexTransform6" type="vec4" count="1"/>
            <parameter name="uTexExtent6" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler3" type="texture2d" index="3" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler4" type="texture2d" index="4" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler5" type="texture2d" index="5" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler6" type="texture2d" index="6" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_7" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;
        uniform vec4 uTexTransform2;
        uniform vec4 uTexExtent2;
        uniform vec4 uTexTransform3;
        uniform vec4 uTexExtent3;
        uniform vec4 uTexTransform4;
        uniform vec4 uTexExtent4;
        uniform vec4 uTexTransform5;
        uniform vec4 uTexExtent5;
        uniform vec4 uTexTransform6;
        uniform vec4 uTexExtent6;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
         varying float vAtmosphere;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;
        uniform sampler2D uSampler4;
        uniform sampler2D uSampler5;
        uniform sampler2D uSampler6;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            color = sampleAndBlend( color, uSampler2, texcoords, uTexExtent2,uTexTransform2, textureAlpha );
            color = sampleAndBlend( color, uSampler3, texcoords, uTexExtent3,uTexTransform3, textureAlpha );
            color = sampleAndBlend( color, uSampler4, texcoords, uTexExtent4,uTexTransform4, textureAlpha );
            color = sampleAndBlend( color, uSampler5, texcoords, uTexExtent5,uTexTransform5, textureAlpha );
            color = sampleAndBlend( color, uSampler6, texcoords, uTexExtent6,uTexTransform6, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>

        <shaderParameter name="ps_terrain_8">
            <parameter name="uTexTransform0" type="vec4" count="1"/>
            <parameter name="uTexExtent0" type="vec4" count="1"/>
            <parameter name="uTexTransform1" type="vec4" count="1"/>
            <parameter name="uTexExtent1" type="vec4" count="1"/>
            <parameter name="uTexTransform2" type="vec4" count="1"/>
            <parameter name="uTexExtent2" type="vec4" count="1"/>
            <parameter name="uTexTransform3" type="vec4" count="1"/>
            <parameter name="uTexExtent3" type="vec4" count="1"/>
            <parameter name="uTexTransform4" type="vec4" count="1"/>
            <parameter name="uTexExtent4" type="vec4" count="1"/>
            <parameter name="uTexTransform5" type="vec4" count="1"/>
            <parameter name="uTexExtent5" type="vec4" count="1"/>
            <parameter name="uTexTransform6" type="vec4" count="1"/>
            <parameter name="uTexExtent6" type="vec4" count="1"/>
            <parameter name="uTexTransform7" type="vec4" count="1"/>
            <parameter name="uTexExtent7" type="vec4" count="1"/>
            <parameter name="uSampler0" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler1" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler3" type="texture2d" index="3" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler4" type="texture2d" index="4" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler5" type="texture2d" index="5" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler6" type="texture2d" index="6" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler7" type="texture2d" index="7" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_terrain_8" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uTexTransform0;
        uniform vec4 uTexExtent0;
        uniform vec4 uTexTransform1;
        uniform vec4 uTexExtent1;
        uniform vec4 uTexTransform2;
        uniform vec4 uTexExtent2;
        uniform vec4 uTexTransform3;
        uniform vec4 uTexExtent3;
        uniform vec4 uTexTransform4;
        uniform vec4 uTexExtent4;
        uniform vec4 uTexTransform5;
        uniform vec4 uTexExtent5;
        uniform vec4 uTexTransform6;
        uniform vec4 uTexExtent6;
        uniform vec4 uTexTransform7;
        uniform vec4 uTexExtent7;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;
        varying float vAtmosphere;

        uniform sampler2D uSampler0;
        uniform sampler2D uSampler1;
        uniform sampler2D uSampler2;
        uniform sampler2D uSampler3;
        uniform sampler2D uSampler4;
        uniform sampler2D uSampler5;
        uniform sampler2D uSampler6;
        uniform sampler2D uSampler7;

        vec3 sampleAndBlend(    vec3 previousColor,
                                sampler2D texture,
                                vec2 tileTextureCoordinates,
                                vec4 textureCoordinateExtent,
                                vec4 textureCoordinateTranslationAndScale,
                                float textureAlpha )
                              {
                                vec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateExtent.pq - tileTextureCoordinates);
                                textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

                                vec2 translation = textureCoordinateTranslationAndScale.xy;
                                vec2 scale = textureCoordinateTranslationAndScale.zw;
                                vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
                                vec4 sample = texture2D(texture, textureCoordinates);
                                vec3 color = sample.rgb;
                                float alpha = sample.a;
                                color = pow(color, vec3(0.78,0.78,0.78));
                                return mix(previousColor, color, alpha * textureAlpha);
                            }
        void main(void)
        {
            vec3 color = vec3(0.0, 0.0, 0.5);
            float textureAlpha = 1.0;
            vec2 texcoords = clamp(vTextureCoord, 0.0, 1.0);
            color = sampleAndBlend( color, uSampler0, texcoords, uTexExtent0,uTexTransform0, textureAlpha );
            color = sampleAndBlend( color, uSampler1, texcoords, uTexExtent1,uTexTransform1, textureAlpha );
            color = sampleAndBlend( color, uSampler2, texcoords, uTexExtent2,uTexTransform2, textureAlpha );
            color = sampleAndBlend( color, uSampler3, texcoords, uTexExtent3,uTexTransform3, textureAlpha );
            color = sampleAndBlend( color, uSampler4, texcoords, uTexExtent4,uTexTransform4, textureAlpha );
            color = sampleAndBlend( color, uSampler5, texcoords, uTexExtent5,uTexTransform5, textureAlpha );
            color = sampleAndBlend( color, uSampler6, texcoords, uTexExtent6,uTexTransform6, textureAlpha );
            color = sampleAndBlend( color, uSampler7, texcoords, uTexExtent7,uTexTransform7, textureAlpha );
            gl_FragColor = vec4(color, textureAlpha);

            float atmo =  vAtmosphere;
            gl_FragColor += (vec4(0.9,0.95,1.0,1.0) - gl_FragColor)*atmo;
        }
      ]]>
        </shader>

        <!--Model Shader-->
        <shaderParameter name="vs_model">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_model" type="vertex_shader" input="FVFXyzTex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec2 texcoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        void main(void) 
        {
          gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
          vTextureCoord = texcoord;
          vLightWeighting = vec3(1.0, 1.0, 1.0);
        }
      ]]>
        </shader>

        <shaderParameter name="ps_model">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_model" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;

        varying vec2 vTextureCoord;
        varying vec3 vLightWeighting;

        uniform sampler2D uSampler;

        void main(void)
        {
          vec4 textureColor = texture2D(uSampler, vTextureCoord);
          gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        }
      ]]>
        </shader>

        <!--Model Shader-->
        <shaderParameter name="vs_model2">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_model2" type="vertex_shader" input="FVFXyzDiffuse" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec4 color;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec4 vColor;
        varying vec3 vLightWeighting;

        void main(void)
        {
          gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
          vColor = color;
          vLightWeighting = vec3(1.0, 1.0, 1.0);
        }
      ]]>
        </shader>


        <shaderParameter name="ps_model2">
        </shaderParameter>
        <shader name="ps_model2" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;

        varying vec4 vColor;
        varying vec3 vLightWeighting;

        //uniform sampler2D uSampler;

        void main(void)
        {
          //vec4 textureColor = texture2D(uSampler, vTextureCoord);
          gl_FragColor = vec4(vColor.bgr * vLightWeighting, 1.0);

        }
      ]]>
        </shader>

        <!--Model Shader-->
        <shaderParameter name="vs_model3">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="minBoundary" type="vec4" count="1"/>
            <parameter name="maxBoundary" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_model3" type="vertex_shader" input="FVFXyzDiffuse" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec4 color;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        uniform vec4 minBoundary;
        uniform vec4 maxBoundary;

        varying vec4 vColor;
        varying vec3 vLightWeighting;

        void main(void)
        {
          vec4 newPositon = vec4(0.0,0.0,0.0,1.0);
          newPositon.x = (position.x * (maxBoundary.x - minBoundary.x) / 60000.0) + minBoundary.x;
          newPositon.y = (position.y * (maxBoundary.y - minBoundary.y) / 60000.0) + minBoundary.y;
          newPositon.z = (position.z * (maxBoundary.z - minBoundary.z) / 60000.0) + minBoundary.z;
          gl_Position = uPMatrix * uMVMatrix * newPositon;
          vColor = color;
          vLightWeighting = vec3(1.0, 1.0, 1.0);
        }
      ]]>
        </shader>
        <shaderParameter name="vs_model4">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_model4" type="vertex_shader" input="FVFXyzTex2" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec2 texcoord;
        attribute vec2 texcoord2;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTextureCoord;
        varying vec2 vTextureCoord2;
        varying vec3 vLightWeighting;

        void main(void)
        {
          gl_Position = uPMatrix * uMVMatrix * vec4(position.x, position.y, position.z, 1.0);
          vTextureCoord = texcoord;
          vTextureCoord2 = texcoord2;
          vLightWeighting = vec3(1.0, 1.0, 1.0);
        }
      ]]>
        </shader>

        <shaderParameter name="ps_model4">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_model4" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;

        varying vec2 vTextureCoord;
        varying vec2 vTextureCoord2;
        varying vec3 vLightWeighting;


        uniform sampler2D uSampler;
        uniform sampler2D uSampler2;

        void main(void)
        {
          vec4 textureColor = texture2D(uSampler, vTextureCoord);
          vec4 textureColor2 = texture2D(uSampler2, vTextureCoord2);
          gl_FragColor = vec4(textureColor.rgb * textureColor2.rgb * vLightWeighting, textureColor.a);
        }
      ]]>
        </shader>

        <!--&lt;!&ndash;Polyline Shader&ndash;&gt;-->
        <!--<shaderParameter name="vs_polyline">-->
        <!--<parameter name="uMVMatrix" type="mat4" count="1"/>-->
        <!--<parameter name="uPMatrix" type="mat4" count="1"/>-->
        <!--</shaderParameter>-->
        <!--<shader name="vs_polyline"  type="vertex_shader" input="FVFXyz"  language="glsl">-->
        <!--<![CDATA[-->
        <!--attribute vec3 position;-->

        <!--uniform mat4 uMVMatrix;-->
        <!--uniform mat4 uPMatrix;-->


        <!--void main()-->
        <!--{-->
        <!--gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);-->
        <!--}-->
        <!--]]>-->
        <!--</shader>-->
        <!--<shaderParameter name="ps_polyline">-->
        <!--<parameter name="uColor" type="vec4" count="1"/>-->
        <!--</shaderParameter>-->
        <!--<shader name="ps_polyline" type="pixel_shader" language="glsl">-->
        <!--<![CDATA[-->
        <!--precision mediump float;-->
        <!--uniform vec4 uColor;-->

        <!--void main(void)-->
        <!--{-->
        <!--gl_FragColor = uColor;-->
        <!--}-->
        <!--]]>-->
        <!--</shader>-->

        <!--Polyline Shader-->
        <shaderParameter name="vs_polyline">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="uLineWidth" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_polyline" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec3 normal;
        attribute vec2 texcoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform vec4 uLineWidth;

        void main()
        {
          vec3 pos = position + normal * texcoord.s * uLineWidth.x;
          gl_Position = uPMatrix * uMVMatrix * vec4(pos, 1.0);
        }
       ]]>
        </shader>
        <shaderParameter name="ps_polyline">
            <parameter name="uColor" type="vec4" count="1"/>
            <parameter name="uBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_polyline" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        uniform vec4 uColor;
        uniform vec4 uBlendColor;

        void main(void)
        {
           gl_FragColor = uColor * uBlendColor;
        }
      ]]>
        </shader>

        <!--Textured Polyline Shader-->
        <shaderParameter name="vs_textured_polyline">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="uLineWidth" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_textured_polyline" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec3 normal;
        attribute vec2 texcoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform vec4 uLineWidth;

        varying vec2 vTextureCoord;

        void main()
        {
              vec3 pos = position + normal * texcoord.s * uLineWidth.x;
              gl_Position = uPMatrix * uMVMatrix * vec4(pos, 1.0);
              vTextureCoord.s = (texcoord.t + uLineWidth.x) / uLineWidth.y;
        }
       ]]>
        </shader>

        <shaderParameter name="vs_volume_polyline">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="uLineWidth" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_volume_polyline" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec3 normal;
        attribute vec2 texcoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform vec4 uLineWidth;

        varying vec2 vTextureCoord;

        void main()
        {
              vec3 pos = position + normal * texcoord.s * uLineWidth.x;
              gl_Position = uPMatrix * uMVMatrix * vec4(pos, 1.0);
              gl_Position.z = gl_Position.z * 0.1;
              vTextureCoord.s = 0.0;
              vTextureCoord.t = texcoord.t;
        }
       ]]>
        </shader>



        <!--Polygon Shader-->
        <shaderParameter name="vs_polygon">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_polygon" type="vertex_shader" input="FVFXyzTex" language="glsl">
            <![CDATA[
                attribute vec3 position;
                attribute vec2 texcoord;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                varying vec2 vTextureCoord;

                void main()
                {
                    gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
                    vTextureCoord = texcoord;
                }
            ]]>
        </shader>
        <shaderParameter name="ps_polygon">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uBlendColor" type="vec4" count="1"/>
             <parameter name="uVisibleAngle" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_polygon" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                uniform sampler2D uSampler;
                uniform vec4 uBlendColor;
                uniform vec4 uVisibleAngle;
                varying vec2 vTextureCoord;

                float getAngel(vec2 ts)
                {
                    const float PI = 3.14159265;
                    //float angel =0.0;
                    vec3 dir =  vec3(ts.x, ts.y, 0.0) - vec3(0.5, 0.5, 0.0);
                    dir = normalize(dir);
                    float angel = acos(dot(dir, vec3(0.0, -1.0, 0.0)));
                    if(dir.x < 0.0){
                        angel = PI * 2.0 - angel;
                    }
                    return angel;
                }

                void main(void)
                {
                    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * uBlendColor;
                    float angel = getAngel(vTextureCoord);
                    if(angel < uVisibleAngle.x ||  angel > uVisibleAngle.y){
                        gl_FragColor.a = 0.0;
                    }
                }
            ]]>
        </shader>


        <!--TexturedVolume Shader-->
        <shaderParameter name="vs_textured_volume">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_textured_volume" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
                attribute vec3 position;
                attribute vec3 normal;
                attribute vec2 texcoord;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                uniform mat4 LightColorMatrix;
                

                vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
                    vec4 lightResult;
                    lightResult.x = max(dot(normal, uKeyLightDir), 0.0);
                    lightResult.y = max(dot(normal, uBackLightDir), 0.0);
                    lightResult.z = max(dot(normal, uFillLightDir), 0.0);
                    lightResult.w = 1.0;
                    lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);
                    vTextureCoord = texcoord;
                }
            ]]>
        </shader>        
        <shaderParameter name="ps_textured_volume">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_textured_volume" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                uniform sampler2D texSampler;
                uniform vec4 vBlendColor;
                //vec4 vBlendColor = vec4(1.0, 1.0, 0.0, 1.0);

                vec4 finalColor;
                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    //float c = (vTextureCoord.x <= 0.1 || vTextureCoord.x >=0.9 || vTextureCoord.y <= 0.1 || vTextureCoord.y >= 0.9)? 0.0 : 1.0;
                    //finalColor = vec4(c,c,c,1.0-c);
                    //vec2 delta = vTextureCoord - vec2(0.5,0.5); //delta position from center;
                    //float dist = 0.5 - sqrt(delta.x*delta.x + delta.y*delta.y);
                    //float border = 0.01;
                    //float a = 0.0;
                    //if(dist > border) a = 1.0;
                    //else if(dist > 0.0) a = dist / border;


                    //finalColor = vec4(0.0,0.0,0.0,a);
                    vec4 clr = texture2D(texSampler, vTextureCoord);
                    gl_FragColor = clr * vBlendColor * lightColor;
                    gl_FragColor.a = clr.a;
                }
            ]]>
        </shader>

        <!--TexturedVolume Shader-->
        <shaderParameter name="vs_textured_volume2">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_textured_volume2" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
                attribute vec3 position;
                attribute vec3 normal;
                attribute vec2 texcoord;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                uniform mat4 LightColorMatrix;
                

                vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
                    vec4 lightResult;
                    lightResult.x = max(dot(normal, uKeyLightDir), 0.0);
                    lightResult.y = max(dot(normal, uBackLightDir), 0.0);
                    lightResult.z = max(dot(normal, uFillLightDir), 0.0);
                    lightResult.w = 1.0;
                    lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);
                    vTextureCoord = texcoord;
                }
            ]]>
        </shader>        
        <shaderParameter name="ps_textured_volume2">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_textured_volume2" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform vec4 vBlendColor;
                //vec4 vBlendColor = vec4(1.0, 1.0, 0.0, 1.0);

                vec4 finalColor;
                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    //finalColor = vec4(0.0,0.0,0.0,a);
                    vec4 clr = texture2D(texSampler, vTextureCoord);
                    vec4 clr2 = texture2D(texSampler2, vTextureCoord);

                    gl_FragColor = clr * clr2 * vBlendColor * lightColor;
                    gl_FragColor.a = clr.a;
                    if(gl_FragColor.a < 0.2){
                        discard;
                    }
                }
            ]]>
        </shader>


        <shaderParameter name="ps_textured_volume_shadow_map_gen">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_textured_volume_shadow_map_gen" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;

                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    vec4 clr = texture2D(texSampler, vTextureCoord);
                    gl_FragColor = vec4(0.0,0.0,0.0,clr.a) * lightColor;
                    //gl_FragColor.a = clr.a;
                }

            ]]>
        </shader>


        <shaderParameter name="vs_textured_volume_shadow_map">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="TexParam" type="vec4"   count="1"/>
            <parameter name="BoundayBox" type="vec4"   count="1"/>
        </shaderParameter>
        <shader name="vs_textured_volume_shadow_map" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
                attribute vec3 position;
                attribute vec3 normal;
                attribute vec2 texcoord;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                uniform mat4 LightColorMatrix;
                uniform vec4 TexParam;
                uniform vec4 BoundayBox;
                

                vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
                    vec4 lightResult;
                    lightResult.x = max(dot(normal, uKeyLightDir), 0.0);
                    lightResult.y = max(dot(normal, uBackLightDir), 0.0);
                    lightResult.z = max(dot(normal, uFillLightDir), 0.0);
                    lightResult.w = 1.0;
                    lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);

                    outTexcoord2 = vec2(position.x - BoundayBox.x, position.y-BoundayBox.y);
                    outTexcoord2 = outTexcoord2 * vec2(1.0/(BoundayBox.z-BoundayBox.x), 1.0/(BoundayBox.w-BoundayBox.y));
                    //outTexcoord2 = outTexcoord2*TexParam.xy ;//+ vec2(0.5, position.z/(BoundayBox.y-BoundayBox.x))*TexParam.zw;
                    outTexcoord = texcoord;
                }
            ]]>
        </shader>  
        <shaderParameter name="ps_textured_volume_shadow_map">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_textured_volume_shadow_map" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform vec4 vBlendColor;


                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    vec4 clr = texture2D(texSampler, outTexcoord);
                    vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    gl_FragColor = clr * clr2 * vBlendColor * lightColor;
                    gl_FragColor.a = clr.a;
                }

            ]]>
        </shader>

        <!--Polyline Shader-->
        <shaderParameter name="vs_polyline2">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="uLineWidth" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_polyline2" type="vertex_shader" input="FVFXyzNormal2Tex" language="glsl">
            <![CDATA[
        attribute vec3 position;
        attribute vec3 normal;
        attribute vec3 normal2;
        attribute vec2 texcoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform vec4 uLineWidth;

        varying vec2 vTextureCoord;
        varying highp vec2 greyThreshold;

        void main()
        {
          if ( texcoord.s < 0.0) {
              vTextureCoord.t = 1.0;
          } else {
              vTextureCoord.t = 0.0;
          }

          vTextureCoord.s = (texcoord.t + dot(normal,normal2) * uLineWidth.x) / uLineWidth.y;
          greyThreshold.x = uLineWidth.z;
          greyThreshold.y = texcoord.t;
          vec3 pos = position + normal * texcoord.s * uLineWidth.x;
          gl_Position = uPMatrix * uMVMatrix * vec4(pos, 1.0);
        }
       ]]>
        </shader>
        <shaderParameter name="ps_polyline2">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_polyline2" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        varying vec2 vTextureCoord;
        varying highp vec2 greyThreshold;

        uniform sampler2D uSampler;
        uniform vec4 uBlendColor;

        void main(void)
        {
            vec4 outColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * uBlendColor;
            if(greyThreshold.y < greyThreshold.x)
            {
                outColor.x = 0.68;
                outColor.y = 0.68;
                outColor.z = 0.68;
                outColor.a = 0.7;
                //outColor.w *= 0.5
            }
            gl_FragColor = outColor;
          
        }
      ]]>
        </shader>

        <shaderParameter name="ps_polyline3">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="uBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_polyline3" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;
        varying vec2 vTextureCoord;

        uniform sampler2D uSampler;
        uniform vec4 uBlendColor;

        void main(void)
        {
            gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * uBlendColor;;
          
        }
      ]]>
        </shader>

        <!--ReprojectMercator Shader-->
        <shaderParameter name="vs_reprojectMercator">
            <parameter name="czm_viewportOrthographic" type="mat4" count="1"/>
            <parameter name="u_textureDimensions" type="vec4" count="1"/>
            <!--parameter name="u_textureExtent" type="vec4" count="1"/-->
            <parameter name="u_textureMercatorParam" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_reprojectMercator" type="vertex_shader" input="FVFXyz" language="glsl">
            <![CDATA[
              precision mediump float;
              attribute vec2 position;

              uniform mat4 czm_viewportOrthographic;
              uniform vec4 u_textureDimensions;
              //uniform vec4 u_textureExtent;
              uniform vec4 u_textureMercatorParam;

              //uniform float u_northLatitude;
              //uniform float u_southLatitude;
              //uniform float u_southMercatorYHigh;
              //uniform float u_southMercatorYLow;
              //uniform float u_oneOverMercatorHeight;

              varying vec2 v_textureCoordinates;

              float czm_latitudeToWebMercatorFraction(float latitude, float southMercatorYLow, float southMercatorYHigh, float oneOverMercatorHeight)
              {
                  float sinLatitude = sin(latitude);
                  float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));
                  //mercatorY - southMercatorY in simulated double precision.
                  float t1 = 0.0 - southMercatorYLow;
                  float e = t1 - 0.0;
                  float t2 = ((-southMercatorYLow - e) + (0.0 - (t1 - e))) + mercatorY - southMercatorYHigh;
                  float highDifference = t1 + t2;
                  float lowDifference = t2 - (highDifference - t1);
                  return highDifference * oneOverMercatorHeight + lowDifference * oneOverMercatorHeight;
              }

              void main()
              {
                  float currentLatitude = mix(u_textureDimensions.w, u_textureDimensions.z, position.y);
                  float fraction = czm_latitudeToWebMercatorFraction(currentLatitude, u_textureMercatorParam.y, u_textureMercatorParam.x, u_textureMercatorParam.z);
                  v_textureCoordinates = vec2(position.x, fraction);
                  //gl_Position = czm_viewportOrthographic *  vec4(position.x * u_textureDimensions.x, position.y * u_textureDimensions.y, 0.0, 1.0);
                  gl_Position = vec4(position.x * 2.0 - 1.0, position.y * 2.0 - 1.0, 0.0, 1.0);
              }
       ]]>
        </shader>
        <shaderParameter name="ps_reprojectMercator">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_reprojectMercator" type="pixel_shader" language="glsl">
            <![CDATA[
            precision mediump float;
            uniform sampler2D uSampler;

            varying vec2 v_textureCoordinates;

            void main()
            {
                gl_FragColor = texture2D(uSampler, v_textureCoordinates);
            }
      ]]>
        </shader>

        <shaderParameter name="vs_recceGround">
            <parameter name="UnpackModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="LightDotUnpack" type="vec4" count="1"/>
            <parameter name="MinPosRange" type="vec4" count="1"/>
            <parameter name="MaxPosRange" type="vec4" count="1"/>
            <parameter name="CameraRelativeModelOrigin" type="vec4" count="1"/>
            <parameter name="WorldUp" type="vec4" count="1"/>
            <parameter name="FogIntensities" type="vec4" count="1"/>
            <parameter name="FogRamp" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_recceGround" type="vertex_shader" input="FVFXyzwTex2" language="glsl">
            <![CDATA[
            attribute mediump vec4 Position;
            attribute lowp vec2 UV;
            attribute lowp vec2 UV2;

            varying lowp vec4 ColorVarying;
            varying mediump vec2 DestinationUV;
            varying highp vec2 DestinationUV2;

            uniform highp mat4 UnpackModelViewProjectionMatrix;
            uniform lowp mat4 LightColorMatrix;
            uniform highp vec4 MinUVRange;
            uniform highp vec4 MaxUVRange;
            uniform highp vec4 LightDotUnpack;
            uniform highp vec4 MinPosRange;
            uniform highp vec4 MaxPosRange;
            uniform highp vec4 CameraRelativeModelOrigin;
            uniform lowp vec4 WorldUp;
            uniform lowp vec4 FogIntensities;
            uniform highp vec4 FogRamp;

            lowp float CalcHeightFogDensity(highp vec3 vertexPos) {
                highp vec3 cameraRelativePos = CameraRelativeModelOrigin.xyz + vertexPos;
                highp vec2 rampParams = vec2(dot(cameraRelativePos, WorldUp.xyz), dot(cameraRelativePos, cameraRelativePos));
                lowp vec2 ramps = smoothstep(FogRamp.yz, FogRamp.xw, rampParams);
                lowp vec2 heightAndDistanceFogParams = vec2(ramps.x*ramps.x, ramps.y);
                return clamp(dot(heightAndDistanceFogParams, FogIntensities.xy), 0.0, 1.0);
            }
            void main(void) {
                DestinationUV = mix(MinUVRange.xy, MaxUVRange.xy, UV);
                DestinationUV2 = UV2;
                mediump vec3 unpackedPosition = mix(MinPosRange.xyz, MaxPosRange.xyz, Position.xyz);
                ColorVarying.rgb = (LightColorMatrix * vec4(fract(Position.w * LightDotUnpack.xyz), 1.0)).rgb;
                ColorVarying.a = CalcHeightFogDensity(unpackedPosition);
                gl_Position = UnpackModelViewProjectionMatrix * vec4(Position.rgb, 1.0);
            }
       ]]>
        </shader>
        <shaderParameter name="ps_recceGround">
            <parameter name="GlowmapParam" type="vec4" count="1"/>
            <parameter name="GlowmapColour" type="vec4" count="1"/>
            <parameter name="AmbientColour" type="vec4" count="1"/>
            <parameter name="FogColour" type="vec4" count="1"/>
            <parameter name="Diffuse" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="Glowmap" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_recceGround" type="pixel_shader" language="glsl">
            <![CDATA[
                varying lowp vec4 ColorVarying;
                varying mediump vec2 DestinationUV;
                varying highp vec2 DestinationUV2;

                uniform lowp vec4 GlowmapParam;
                uniform lowp vec4 GlowmapColour;
                uniform lowp vec4 AmbientColour;
                uniform lowp vec4 FogColour;

                uniform sampler2D Diffuse;
                uniform sampler2D Glowmap;
                void main(void) {
                    lowp vec3 diffuse = texture2D(Diffuse,DestinationUV, -1.0).rgb;
                    lowp vec3 dayColour = diffuse * ColorVarying.rgb;
                    lowp float luma = dot(diffuse, vec3(0.3, 0.59, 0.11));
                    lowp vec3 greyscale = vec3(luma, luma, luma);
                    lowp vec3 glow = GlowmapColour.xyz * texture2D(Glowmap,DestinationUV2, -1.0).rgb;
                    lowp vec3 desatDiffuse = mix(greyscale, diffuse, 0.2);
                    lowp vec3 nightColour = desatDiffuse * (glow + AmbientColour.xyz);
                    gl_FragColor.rgb = mix(mix(dayColour, nightColour, GlowmapParam.x), FogColour.rgb, ColorVarying.a);
                }
      ]]>
        </shader>

        <!--ReprojectMercator Shader-->
        <shaderParameter name="vs_recceModel">
            <parameter name="UnpackModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="LightDotUnpack" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_recceModel" type="vertex_shader" input="FVFXyzwTex" language="glsl">
            <![CDATA[
          attribute mediump vec4 position;
          attribute lowp vec2 texcoord;
          varying lowp vec4 ColorVarying;
          varying mediump vec2 DestinationUV;
          uniform highp mat4 UnpackModelViewProjectionMatrix;
          uniform lowp mat4 LightColorMatrix;
          uniform highp vec4 MinUVRange;
          uniform highp vec4 MaxUVRange;
          uniform highp vec4 LightDotUnpack;

        vec3 uKeyLightDir = vec3(0.5, -0.5, 0.70710677);
        vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
        vec3 uFillLightDir = vec3(0.0, 0.0, 1.0);

          void main(void) {
              DestinationUV = mix(MinUVRange.xy, MaxUVRange.xy, texcoord);
                //vec3 transform_normal = fract(position.w * LightDotUnpack.xyz);
                //vec4 lightResult;
                //lightResult.x = max(dot(transform_normal, uKeyLightDir), 0.0);
                //lightResult.y = max(dot(transform_normal, uBackLightDir), 0.0);
                //lightResult.z = max(dot(transform_normal, uFillLightDir), 0.0);
                //lightResult.w = 1.0;
                //ColorVarying = vec4((LightColorMatrix * lightResult).xyz, 1.0);
              ColorVarying = vec4(1.0);//LightColorMatrix * vec4(fract(position.w * LightDotUnpack.xyz), 1.0);
              gl_Position = UnpackModelViewProjectionMatrix * vec4(position.xyz, 1.0);
          }
       ]]>
        </shader>
        <shaderParameter name="ps_recceModel">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_recceModel" type="pixel_shader" language="glsl">
            <![CDATA[
                varying lowp vec4 ColorVarying;
                varying mediump vec2 DestinationUV;
                uniform sampler2D uSampler;
                uniform mediump vec4 vBlendColor;

                void main(void) {
                    lowp vec4 textureColor = texture2D(uSampler, DestinationUV, -1.0);
                    gl_FragColor.rgb = mix( vBlendColor.rgb, textureColor.rgb * ColorVarying.rgb, vBlendColor.a);
                    gl_FragColor.a = textureColor.a * vBlendColor.a;
                    if(gl_FragColor.a <= 0.8){
                        discard;
                    }
                }
           ]]>
        </shader>
        <shaderParameter name="ps_recceModel_Transparency">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
             <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_recceModel_Transparency" type="pixel_shader" language="glsl">
            <![CDATA[
                varying lowp vec4 ColorVarying;
                varying mediump vec2 DestinationUV;
                uniform sampler2D uSampler;
                uniform mediump vec4 vBlendColor;
                
                void main(void) {
                    lowp vec4 textureColor = texture2D(uSampler,DestinationUV, -1.0);
                    gl_FragColor.rgb = mix( vBlendColor.rgb, textureColor.rgb * ColorVarying.rgb, vBlendColor.a);
                    gl_FragColor.a = textureColor.a * vBlendColor.a;
                    if(gl_FragColor.a > 0.8){
                       discard;
                    }
                }
            ]]>
        </shader>
            <shaderParameter name="ps_recceModel_Blend">
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
             <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_recceModel_Blend" type="pixel_shader" language="glsl">
            <![CDATA[
                varying lowp vec4 ColorVarying;
                varying mediump vec2 DestinationUV;
                uniform sampler2D uSampler;
                uniform mediump vec4 vBlendColor;
                
                void main(void) {
                    lowp vec4 textureColor = texture2D(uSampler,DestinationUV, -1.0);
                    gl_FragColor.rgb = mix( vBlendColor.rgb, textureColor.rgb * ColorVarying.rgb, vBlendColor.a);
                    gl_FragColor.a = textureColor.a * vBlendColor.a;
                }
            ]]>
        </shader>


        <!--GLTF Shader-->
        <shaderParameter name="vs_gltf_model">
            <parameter name="uMVMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="uModelMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_gltf_model" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
                attribute vec3 position;
                attribute vec3 normal;
                attribute vec2 texcoord;

                uniform mat4 uMVMatrix;
                uniform mat4 uPMatrix;
                uniform mat4 uModelMatrix;
                uniform mat4 LightColorMatrix;
                

  
                vec3 uKeyLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uBackLightDir = vec3(-0.5, 0.5, -0.70710677);

                //vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                //vec3 uBackLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
                    vec3 transform_normal = normalize((uModelMatrix * vec4(normal, 1.0)).xyz);
                    vec4 lightResult;
                    lightResult.x = max(dot(transform_normal, uKeyLightDir), 0.0);
                    lightResult.y = max(dot(transform_normal, uBackLightDir), 0.0);
                    lightResult.z = max(dot(transform_normal, uFillLightDir), 0.0);
                    lightResult.w = 1.0;
                    lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);
                    vTextureCoord = texcoord;
                }
            ]]>
        </shader>        
        <shaderParameter name="ps_gltf_model">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_gltf_model" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform vec4 vBlendColor;
                //vec4 vBlendColor = vec4(1.0, 1.0, 0.0, 1.0);

                vec4 finalColor;
                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    //finalColor = vec4(0.0,0.0,0.0,a);
                    vec4 clr = texture2D(texSampler, vTextureCoord);
                    vec4 clr2 = texture2D(texSampler2, vTextureCoord);

                    gl_FragColor = clr * clr2 * vBlendColor * lightColor;
                    gl_FragColor.a = clr.a;
                    if(gl_FragColor.a < 0.3){
                        discard;
                    }
                }
            ]]>
        </shader>

        <shaderParameter name="ps_gltf_model_transparency">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_gltf_model_transparency" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform vec4 vBlendColor;
                //vec4 vBlendColor = vec4(1.0, 1.0, 0.0, 1.0);

                vec4 finalColor;
                varying vec2 vTextureCoord;
                varying vec4 lightColor;

                void main()
                {
                    //finalColor = vec4(0.0,0.0,0.0,a);
                    vec4 clr = texture2D(texSampler, vTextureCoord);
                    vec4 clr2 = texture2D(texSampler2, vTextureCoord);

                    gl_FragColor = clr * clr2 * vBlendColor * lightColor;
                    gl_FragColor.a = clr.a;
                    if(gl_FragColor.a >= 0.3){
                        discard;
                    }
                }
            ]]>
        </shader>

        <shaderParameter name="vs_recceModelShadow">
            <parameter name="ModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="MinVertRange" type="vec4" count="1"/>
            <parameter name="MaxVertRange" type="vec4" count="1"/>
            <parameter name="Up" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_recceModelShadow" type="vertex_shader" input="FVFXyzw" language="glsl">
            <![CDATA[
            attribute mediump vec4 position;
            uniform highp mat4 ModelViewProjectionMatrix;
            uniform mediump vec4 MinVertRange;
            uniform mediump vec4 MaxVertRange;
            uniform mediump vec4 Up;
            void main(void) {
                highp vec4 scaledPos = vec4(mix(MinVertRange.xyz, MaxVertRange.xyz, position.xyz), position.w * MaxVertRange.w);
                highp vec3 truePos = scaledPos.xyz;// + (((-Up.xyz)*scaledPos.w*4.0)*(1.0-Up.w));
                gl_Position = ModelViewProjectionMatrix * vec4(truePos, 1.0);

            }
       ]]>
        </shader>

        <shaderParameter name="vs_recceModelShadow2">
            <parameter name="ModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="MinVertRange" type="vec4" count="1"/>
            <parameter name="MaxVertRange" type="vec4" count="1"/>
            <parameter name="Up" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_recceModelShadow2" type="vertex_shader" input="FVFXyzw" language="glsl">
            <![CDATA[
            attribute mediump vec4 position;
            uniform highp mat4 ModelViewProjectionMatrix;
            uniform mediump vec4 MinVertRange;
            uniform mediump vec4 MaxVertRange;
            uniform mediump vec4 Up;
            void main(void) {
                //vec3 lightDotUnpack = vec3(1.0,32.0,1024.0);
                vec3 lightDotUnpack = vec3(-0.562500000,0.437500000,-0.750000000);
                //vec3 unpackNormal = fract(position.w * lightDotUnpack.xyz);
                //unpackNormal = normalize(unpackNormal);
                float length = abs(position.w - 0.25806057831692988479438467994202) * 65535.0/(16912.0-7908.0);
                highp vec4 scaledPos = vec4(mix(MinVertRange.xyz, MaxVertRange.xyz, position.xyz), position.w * MaxVertRange.w);
                // highp vec3 truePos = scaledPos.xyz + (((-Up.xyz)*scaledPos.w*4.0)*(1.0-Up.w));
                highp vec3 truePos = scaledPos.xyz + lightDotUnpack * length * 0.0;
                gl_Position = ModelViewProjectionMatrix * vec4(truePos.xyz, 1.0);

                //vec4 scaledPos = ModelViewProjectionMatrix * vec4(position.xyz, 1.0);
                //gl_Position.xyz = scaledPos.xyz + unpackNormal * MaxVertRange.w;
                //gl_Position.w = 1.0;
            }
       ]]>
        </shader>
        <shaderParameter name="ps_recceModelShadow">
        </shaderParameter>
        <shader name="ps_recceModelShadow" type="pixel_shader" language="glsl">
            <![CDATA[
           void main(void) {
              gl_FragColor.rgb = vec3(0.0,0.0,0.0);
              gl_FragColor.a = 1.0;
           }
      ]]>
        </shader>

        <shaderParameter name="vs_shadowVolumeFill">
            <parameter name="ModelViewProjectionMatrix" type="mat4" count="1"/>
        </shaderParameter>
        <shader name="vs_shadowVolumeFill" type="vertex_shader" input="FVFXyz" language="glsl">
            <![CDATA[
            attribute mediump vec4 position;
            uniform highp mat4 ModelViewProjectionMatrix;
            void main(void) {
                gl_Position = ModelViewProjectionMatrix * vec4(position.xyz, 1.0);
            }
       ]]>
        </shader>
        <shaderParameter name="ps_shadowVolumeFill">
            <parameter name="ColorValue" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_shadowVolumeFill" type="pixel_shader" language="glsl">
            <![CDATA[
          uniform lowp vec4 ColorValue;
           void main(void) {
              gl_FragColor = ColorValue;
              gl_FragColor.a = 1.0;
           }
      ]]>
        </shader>

        <!--recceModelWater Shader-->
        <shaderParameter name="vs_recceModelWater">
            <parameter name="ModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="ModelViewMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="AnimatedUVUniform" type="vec4" count="1"/>
            <parameter name="AltitudeEnvMapFade" type="vec4" count="1"/>
            <parameter name="MinVertRange" type="vec4" count="1"/>
            <parameter name="MaxVertRange" type="vec4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="CameraRelativeModelOrigin" type="vec4" count="1"/>
            <parameter name="WorldUp" type="vec4" count="1"/>
            <parameter name="FogIntensities" type="vec4" count="1"/>
            <parameter name="FogRamp" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="vs_recceModelWater" type="vertex_shader" input="FVFXyzwTex" language="glsl">
            <![CDATA[
            attribute highp vec4 position;
            attribute highp vec2 texcoord;
            varying highp vec2 DestinationUV;
            varying highp vec4 ColorVarying;
            varying highp vec2	DestinationUV2;
            varying highp vec4 ReflectVector;
            uniform highp mat4 ModelViewProjectionMatrix;
            uniform highp mat4 ModelViewMatrix;
            uniform highp mat4 LightColorMatrix;
            uniform highp vec4 AnimatedUVUniform;
            uniform highp vec4 AltitudeEnvMapFade;
            uniform highp vec4 MinVertRange;
            uniform highp vec4 MaxVertRange;
            uniform highp vec4 MinUVRange;
            uniform highp vec4 MaxUVRange;
            uniform highp vec4 CameraRelativeModelOrigin;
            uniform lowp vec4 WorldUp;
            uniform lowp vec4 FogIntensities;
            uniform highp vec4 FogRamp;
            lowp float CalcHeightFogDensity(highp vec3 vertexPos) {
                highp vec3 cameraRelativePos = CameraRelativeModelOrigin.xyz + vertexPos;
                highp vec2 rampParams = vec2(dot(cameraRelativePos, WorldUp.xyz), dot(cameraRelativePos, cameraRelativePos));
                lowp vec2 ramps = smoothstep(FogRamp.yz, FogRamp.xw, rampParams);
                lowp vec2 heightAndDistanceFogParams = vec2(ramps.x*ramps.x, ramps.y);
                return clamp(dot(heightAndDistanceFogParams, FogIntensities.xy), 0.0, 1.0);
            }
            void main(void) {
                highp vec2 baseUVOffset = AnimatedUVUniform.xy * AnimatedUVUniform.zw;
                highp vec2 ScaledUV = mix(MinUVRange.xy, MaxUVRange.xy, texcoord).xy;
                DestinationUV = ScaledUV.xy; //baseUVOffset.xy + (ScaledUV.xy);
                highp vec3 dots = fract(vec3(position.w * 1.0, position.w * 32.0, position.w * 1024.0));
                ColorVarying =vec4(1.0); (LightColorMatrix * vec4(dots, 1.0));
                DestinationUV2 = (ScaledUV * 4.0) + (baseUVOffset * 13.0);
                highp vec3 truePos = mix(MinVertRange.xyz, MaxVertRange.xyz, position.xyz);
                highp vec3 posVS = (ModelViewMatrix * vec4(truePos.xyz, 1.0)).xyz;
                highp vec3 eyeVectorVS = normalize(posVS);
                highp vec3 normal = vec3(0,0,1);
                ReflectVector.xyz = reflect(eyeVectorVS, normal) * 32.0;
                ReflectVector.w = CalcHeightFogDensity(truePos);
                ColorVarying = (ColorVarying * (1.0 - AltitudeEnvMapFade.x)) + (ColorVarying * 0.1);
                ColorVarying.w = AltitudeEnvMapFade.x;
                gl_Position = ModelViewProjectionMatrix * vec4(truePos.xyz, 1.0);
            }
       ]]>
        </shader>
        <shaderParameter name="ps_recceModelWater">
            <parameter name="ReflectionWaveDisplacement" type="vec4" count="1"/>
            <parameter name="FogColour" type="vec4" count="1"/>
            <parameter name="Diffuse" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="NormalMap" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="ReflectionMap" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_recceModelWater" type="pixel_shader" language="glsl">
            <![CDATA[
            varying highp vec4 ColorVarying;
            varying highp vec2 DestinationUV;
            varying highp vec2	DestinationUV2;
            varying highp vec4 ReflectVector;
            uniform lowp vec4 ReflectionWaveDisplacement;
            uniform lowp vec4 FogColour;
            uniform sampler2D Diffuse;
            uniform sampler2D NormalMap;
            uniform sampler2D ReflectionMap;
            void main(void) {
                highp vec4 diffuseColor = texture2D(Diffuse, DestinationUV);
                highp vec2 uv2 = fract(DestinationUV2 * 8.0);
                highp vec3 normal = ((2.0 * texture2D(NormalMap, uv2).xyz) - 1.0);
                highp vec3 refl = normalize(ReflectVector.xyz + normal*ReflectionWaveDisplacement.x);
                highp vec2 uv = ((refl.xy * 0.5) + 0.5);
                highp vec4 reflection = texture2D(ReflectionMap, uv);
                lowp vec3 colour = (diffuseColor.xyz * ColorVarying.xyz) + (reflection.xyz * ColorVarying.w);
                gl_FragColor.rgb = mix(colour, FogColour.rgb, ReflectVector.w);
                gl_FragColor.a = 1.0;
                
            }
      ]]>
        </shader>


        <!--Model Shader(T23)-->
        <shaderParameter name="vs_json_model_normal">
            <parameter name="modelViewMatrix" type="mat4" count="1"/>
            <parameter name="uPMatrix" type="mat4" count="1"/>
            <parameter name="modelMatrix" type="mat4" count="1"/>
            <parameter name="viewMatrix" type="mat4" count="1"/>
            <parameter name="normalMatrix" type="mat4" count="1"/>

            <parameter name="offsetRepeat" type="vec4" count="1"/>
            <parameter name="ambient" type="vec4" count="1"/>
            <parameter name="diffuse" type="vec4" count="1"/>
            <parameter name="emissive" type="vec4" count="1"/>
            <parameter name="ambientLightColor" type="vec4" count="1"/>
            <parameter name="directionalLightColor0" type="vec4" count="1"/>
            <parameter name="directionalLightColor1" type="vec4" count="1"/>
            <parameter name="directionalLightDirection0" type="vec4" count="1"/>
            <parameter name="directionalLightDirection1" type="vec4" count="1"/>
            <parameter name="hemisphereLightSkyColor" type="vec4" count="1"/>
            <parameter name="hemisphereLightGroundColor" type="vec4" count="1"/>
            <parameter name="hemisphereLightDirection" type="vec4" count="1"/>
            <parameter name="spotLightColor" type="vec4" count="1"/>
            <parameter name="spotLightPosition" type="vec4" count="1"/>
            <parameter name="spotLightDirection" type="vec4" count="1"/>
            <parameter name="spotLightFloat" type="vec4" count="1"/>

        </shaderParameter>
        <shader name="vs_json_model_normal" type="vertex_shader" input="FVFXyzNormalTex" language="glsl">
            <![CDATA[
            uniform mat4 modelViewMatrix;
            uniform mat4 uPMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 modelMatrix;
            uniform mat4 normalMatrix;

            uniform vec4 offsetRepeat;
            uniform vec4 ambient;
            uniform vec4 diffuse;
            uniform vec4 emissive;

            uniform vec4 ambientLightColor;

            uniform vec4 directionalLightColor0;
            uniform vec4 directionalLightColor1;

            uniform vec4 directionalLightDirection0;
            uniform vec4 directionalLightDirection1;

            uniform vec4 hemisphereLightSkyColor;
            uniform vec4 hemisphereLightGroundColor;
            uniform vec4 hemisphereLightDirection;

            uniform vec4 spotLightColor;
            uniform vec4 spotLightPosition;
            uniform vec4 spotLightDirection;

            uniform vec4 spotLightFloat;

            attribute vec3 position;
            attribute vec3 normal;
            attribute vec2 texcoord;

            varying vec3 vLightFront;
            varying vec2 vUv;
            void main(void) {
                vUv = texcoord * offsetRepeat.zw + offsetRepeat.xy;
                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vec4 mvPosition;
                mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_Position = uPMatrix * mvPosition;
                vec4 transformedNormal = normalMatrix * vec4( normal, 0.0);
                vLightFront = vec3( 0.0 );


                vec4 lDirection = viewMatrix * directionalLightDirection0;
                vec3 dirVector = normalize( lDirection.xyz );
                float dotProduct = dot( transformedNormal.xyz, dirVector );
                vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
                vLightFront += directionalLightColor0.xyz * directionalLightWeighting;

                vec4 lDirection1 = viewMatrix * directionalLightDirection1;
                vec3 dirVector1 = normalize( lDirection1.xyz );
                float dotProduct1 = dot( transformedNormal.xyz, dirVector1 );
                vec3 directionalLightWeighting1 = vec3( max( dotProduct1, 0.0 ) );
                vLightFront += directionalLightColor1.xyz * directionalLightWeighting1;


                vec4 lPosition = viewMatrix * spotLightPosition;
                vec3 lVector = lPosition.xyz - mvPosition.xyz;
                float spotEffect = dot( spotLightDirection.xyz, normalize( spotLightPosition.xyz - worldPosition.xyz ) );
                float spotLightAngleCos = spotLightFloat.y;
                float spotLightExponent = spotLightFloat.z;
                if ( spotEffect > spotLightAngleCos ) {
                    spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent ), 0.0 );
                    float lDistance = 1.0;
                    float spotLightDistance = spotLightFloat.x;
                    if ( spotLightDistance > 0.0 )
                    lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance ), 1.0 );
                    lVector = normalize( lVector );
                    float dotProduct = dot( transformedNormal.xyz, lVector );
                    vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );
                    vLightFront += spotLightColor.xyz * spotLightWeighting * lDistance * spotEffect;
                }

                lDirection = viewMatrix * hemisphereLightDirection;
                dirVector = normalize( lDirection.xyz );
                dotProduct = dot( transformedNormal.xyz, dirVector );
                float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;
                float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;
                vLightFront += mix( hemisphereLightGroundColor.xyz, hemisphereLightSkyColor.xyz, hemiDiffuseWeight );


                vLightFront = vLightFront * diffuse.xyz + ambient.xyz * ambientLightColor.xyz + emissive.xyz;

            }
        ]]>
        </shader>
        <!--<shader>-->


        <!--</shader>-->

        <shaderParameter name="ps_json_model_normal">
            <parameter name="opacity" type="vec4" count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_json_model_normal" type="pixel_shader" language="glsl">
            <![CDATA[
        precision mediump float;

        varying vec3 vLightFront;
        varying vec2 vUv;

       // uniform float opacity;
        uniform vec4 opacity;
        uniform sampler2D uSampler;
        void main(void) {
        gl_FragColor = vec4( vec3( 1.0 ), opacity.x );
        vec4 texelColor = texture2D( uSampler, vUv );
        gl_FragColor = gl_FragColor * texelColor;
        //if ( gl_FragColor.a < ALPHATEST ) discard;
        //float specularStrength = 1.0;
        gl_FragColor.xyz *= vLightFront;
        }
      ]]>
        </shader>

        <!--David -->
        <shaderParameter name="vs_flake_line">
            <parameter name="g_WorldViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="g_matViewProj" type="mat4" count="1"/>
            <parameter name="g_viewportScale"             type="vec4"   count="1"/>
        </shaderParameter>
        <shader name="vs_flake_line" type="vertex_shader" input="FVFXyzNormal" language="glsl">
            <![CDATA[

        uniform mat4 g_WorldViewProjectionMatrix;
        uniform mat4 g_matViewProj;
        uniform vec4 g_viewportScale;

        attribute vec3  position;
        attribute vec3  normal;
        //attribute vec4  color;

       // varying vec4 diffuse;

        void main()
        {
            vec4 pos = g_WorldViewProjectionMatrix * vec4(position,1.0);
            vec4 nor = g_matViewProj * vec4(normal, 0);
            nor = normalize(vec4(cross( vec3(nor.xy, 0), vec3( 0,0,1)), 0));
            gl_Position.xy = pos.xy + nor.xy * pos.w * g_viewportScale.xy ;
            gl_Position.zw = pos.zw;
           // diffuse = color;
        }
      ]]>
        </shader>
        <shaderParameter name="ps_flake_line">
            <parameter name="g_color" type="vec4" count="1"/>
        </shaderParameter>
        <shader name="ps_flake_line" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;
                uniform vec4 g_color;

                //varying vec4 diffuse;

                void main()
                {
                    gl_FragColor = g_color;
                }
            ]]>
        </shader>

        <!--RSModel Common -->
        <shaderParameter name="vs_RSModelCommon">
            <parameter name="UnpackModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="UnpackModelMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="LightDotUnpack" type="vec4" count="1"/>
            <parameter name="TexParam" type="vec4"   count="1"/>
            <parameter name="BoundayBox" type="vec4"   count="1"/>

        </shaderParameter>
        <shader name="vs_RSModelCommon" type="vertex_shader" input="FVFXyzwTex" language="glsl">
            <![CDATA[

                uniform mat4 UnpackModelViewProjectionMatrix;
                uniform mat4 UnpackModelMatrix;
                uniform mat4 LightColorMatrix;
                uniform vec4 MinUVRange;
                uniform vec4 MaxUVRange;
                uniform vec4 LightDotUnpack;
                uniform vec4 TexParam;
                uniform vec4 BoundayBox;


                attribute vec4 position;
                attribute vec2 texcoord;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    lightColor = vec4(1.0);//LightColorMatrix * vec4(fract(position.w * LightDotUnpack.xyz), 1.0);
                    gl_Position = UnpackModelViewProjectionMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = mix(MinUVRange.xy, MaxUVRange.xy, texcoord);
                    vec4 positionUnpack = UnpackModelMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = outTexcoord - vec2(0.0,0.01);
                    outTexcoord2 = vec2(positionUnpack.x - BoundayBox.x, positionUnpack.y-BoundayBox.y);
                    outTexcoord2 = outTexcoord2 * vec2(1.0/(BoundayBox.z-BoundayBox.x), 1.0/(BoundayBox.w-BoundayBox.y));
                    outTexcoord2 = outTexcoord2*TexParam.xy + vec2(0.5, positionUnpack.z/(BoundayBox.y-BoundayBox.x))*TexParam.zw;
                }
            ]]>
        </shader>

        <shaderParameter name="ps_RSModelCommon">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4"   count="1"/>
        </shaderParameter>
        <shader name="ps_RSModelCommon" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform mediump vec4 vBlendColor;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    vec4 clr = texture2D(texSampler, outTexcoord);
                    vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    gl_FragColor.rgb = mix(vBlendColor.rgb, clr.rgb * clr2.rgb * lightColor.rgb, vBlendColor.a);
                    gl_FragColor.a = clr.a * vBlendColor.a;
                    if(gl_FragColor.a < 0.8){
                        discard;
                    }
                }

            ]]>
        </shader>

        <shaderParameter name="ps_RSModelCommon_Transparency">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4"   count="1"/>
        </shaderParameter>
        <shader name="ps_RSModelCommon_Transparency" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform mediump vec4 vBlendColor;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    vec4 clr = texture2D(texSampler, outTexcoord);
                    vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    gl_FragColor.rgb = mix(vBlendColor.rgb, clr.rgb * clr2.rgb * lightColor.rgb, vBlendColor.a);
                    gl_FragColor.a = clr.a * vBlendColor.a;
                    if(gl_FragColor.a >= 0.8){
                        discard;
                    }
                }
            ]]>
        </shader>
        
        <shaderParameter name="ps_RSModelCommon_Blend">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4"   count="1"/>
        </shaderParameter>
        <shader name="ps_RSModelCommon_Blend" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform mediump vec4 vBlendColor;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    vec4 clr = texture2D(texSampler, outTexcoord);
                    vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    gl_FragColor.rgb = mix(vBlendColor.rgb, clr.rgb * clr2.rgb * lightColor.rgb, vBlendColor.a);
                    gl_FragColor.a = clr.a * vBlendColor.a;
                }
            ]]>
        </shader>

        <!--RSModel Common2 -->
        <shaderParameter name="vs_RSModelWithGlow">
            <parameter name="UnpackModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="UnpackModelMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="LightDotUnpack" type="vec4" count="1"/>
            <parameter name="TexParam" type="vec4"   count="1"/>
            <parameter name="BoundayBox" type="vec4"   count="1"/>

        </shaderParameter>
        <shader name="vs_RSModelWithGlow" type="vertex_shader" input="FVFXyzwTex" language="glsl">
            <![CDATA[

                uniform mat4 UnpackModelViewProjectionMatrix;
                uniform mat4 UnpackModelMatrix;
                uniform mat4 LightColorMatrix;
                uniform vec4 MinUVRange;
                uniform vec4 MaxUVRange;
                uniform vec4 LightDotUnpack;
                uniform vec4 TexParam;
                uniform vec4 BoundayBox;


                attribute vec4 position;
                attribute vec2 texcoord;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                void main()
                {
                    vec3 normal = vec3(fract(position.w * LightDotUnpack.xyz * 2.0)) - vec3(1.0,1.0,1.0);
                    vec4 lightResult;
                    lightResult.x = max(dot(normal, uKeyLightDir), 0.0);
                    lightResult.y = max(dot(normal, uBackLightDir), 0.0);
                    lightResult.z = max(dot(normal, uFillLightDir), 0.0);
                    lightResult.w = 1.0;
                    lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);
                    //lightColor = LightColorMatrix * vec4(fract(position.w * LightDotUnpack.xyz), 1.0);
                    gl_Position = UnpackModelViewProjectionMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = mix(MinUVRange.xy, MaxUVRange.xy, texcoord);
                    vec4 positionUnpack = UnpackModelMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = outTexcoord - vec2(0.0,0.01);
                    outTexcoord2 = vec2(positionUnpack.x - BoundayBox.x, positionUnpack.y-BoundayBox.y);
                    outTexcoord2 = outTexcoord2 * vec2(1.0/(BoundayBox.z-BoundayBox.x), 1.0/(BoundayBox.w-BoundayBox.y));
                    outTexcoord2 = outTexcoord2*TexParam.xy + vec2(0.5, positionUnpack.z/(BoundayBox.y-BoundayBox.x))*TexParam.zw;
                }
            ]]>
        </shader>

        <shaderParameter name="ps_RSModelWithGlow">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="glowSampler" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
            <parameter name="vBlendColor" type="vec4"   count="1"/>
        </shaderParameter>
        <shader name="ps_RSModelWithGlow" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform sampler2D glowSampler;
                uniform mediump vec4 vBlendColor;
                
                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    //vec4 clr = texture2D(texSampler, outTexcoord);
                    //vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    //gl_FragColor = clr * clr2 * lightColor;
                    //gl_FragColor.a = clr.a;

                    vec4 clr = texture2D(texSampler, outTexcoord);
                    vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    lowp vec3 diffuse = (clr * clr2).rgb;
                    //lowp vec3 diffuse = texture2D(texSampler,outTexcoord, -1.0).rgb;
                    lowp vec3 dayColour = diffuse * lightColor.rgb;

                    lowp vec3 glowColor = texture2D(glowSampler,outTexcoord2, -1.0).rgb;
                    lowp vec3 glow = vec3(6.0, 6.0, 6.0) * glowColor;
                    lowp float luma = dot(glowColor, vec3(0.3, 0.59, 0.11));
                    lowp vec3 greyscale = vec3(luma, luma, luma);
                    lowp vec3 desatDiffuse = mix(greyscale, diffuse, 0.3);
                    lowp vec3 nightColour = desatDiffuse * (glow + vec3(0.2, 0.2, 0.2));
                    gl_FragColor.rgb = mix(dayColour, nightColour,  0.4);
                    gl_FragColor.a = clr.a * vBlendColor.a;
                }
            ]]>
        </shader>

        <!--RSWallWithGlow -->
        <shaderParameter name="vs_RSWallWithGlow">
            <parameter name="UnpackModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="UnpackModelMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="LightDotUnpack" type="vec4" count="1"/>
            <parameter name="TexParam" type="vec4"   count="1"/>
            <parameter name="BoundayBox" type="vec4"   count="1"/>

        </shaderParameter>
        <shader name="vs_RSWallWithGlow" type="vertex_shader" input="FVFXyzwTex" language="glsl">
            <![CDATA[
                uniform mat4 UnpackModelViewProjectionMatrix;
                uniform mat4 UnpackModelMatrix;
                uniform mat4 LightColorMatrix;
                uniform vec4 MinUVRange;
                uniform vec4 MaxUVRange;
                uniform vec4 LightDotUnpack;
                uniform vec4 TexParam;
                uniform vec4 BoundayBox;


                attribute vec4 position;
                attribute vec2 texcoord;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                void main()
                {
                    vec3 normal = vec3(fract(position.w * LightDotUnpack.xyz * 2.0)) - vec3(1.0,1.0,1.0);
                    vec4 lightResult;
                    lightResult.x = max(dot(normal, uKeyLightDir), 0.0);
                    lightResult.y = max(dot(normal, uBackLightDir), 0.0);
                    lightResult.z = max(dot(normal, uFillLightDir), 0.0);
                    lightResult.w = 1.0;
                    lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);
                    //lightColor = LightColorMatrix * vec4(fract(position.w * LightDotUnpack.xyz), 1.0);
                    gl_Position = UnpackModelViewProjectionMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = mix(MinUVRange.xy, MaxUVRange.xy, texcoord);
                    vec4 positionUnpack = UnpackModelMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = outTexcoord - vec2(0.0,0.01);
                    outTexcoord2 = outTexcoord;
                    //outTexcoord2 = vec2(positionUnpack.x - BoundayBox.x, positionUnpack.y-BoundayBox.y);
                    //outTexcoord2 = outTexcoord2 * vec2(1.0/(BoundayBox.z-BoundayBox.x), 1.0/(BoundayBox.w-BoundayBox.y));
                    //outTexcoord2 = outTexcoord2*TexParam.xy + vec2(0.5, positionUnpack.z/(BoundayBox.y-BoundayBox.x))*TexParam.zw;
                }
            ]]>
        </shader>

        <shaderParameter name="ps_RSWallWithGlow">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/>
            <parameter name="glowSampler" type="texture2d" index="2" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_RSWallWithGlow" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                uniform sampler2D texSampler2;
                uniform sampler2D glowSampler;
                

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;

                void main()
                {
                    //vec4 clr = texture2D(texSampler, outTexcoord);
                    //vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    //gl_FragColor = clr * clr2 * lightColor;
                    //gl_FragColor.a = clr.a;

                    vec4 clr = texture2D(texSampler, outTexcoord);
                    vec4 clr2 = texture2D(texSampler2, outTexcoord2);
                    vec4 glowColor = texture2D(glowSampler,outTexcoord2);
                    lowp vec3 diffuse = (clr * clr2).rgb;
                    //diffuse = mix(diffuse, glowColor.rgb, glowColor.a);
                    //lowp vec3 diffuse = texture2D(texSampler,outTexcoord, -1.0).rgb;
                    lowp vec3 dayColour = diffuse * lightColor.rgb;

    
                    lowp vec3 glow = vec3(1.6, 1.6, 1.6) * glowColor.rgb;
                    lowp float luma = dot(glowColor.rgb, vec3(0.3, 0.59, 0.11));
                    lowp vec3 greyscale = vec3(luma, luma, luma);
                    lowp vec3 desatDiffuse = mix(greyscale, diffuse, 0.6); //greyscale * diffuse;
                    lowp vec3 nightColour = desatDiffuse * (glow + vec3(0.2, 0.2, 0.2));
                    gl_FragColor.rgb = mix(dayColour, nightColour.rgb, glowColor.a);
                    gl_FragColor.a = clr.a;
                }

            ]]>
        </shader>


        <shaderParameter name="vs_RSShadowMapGen">
            <parameter name="UnpackModelViewProjectionMatrix" type="mat4" count="1"/>
            <parameter name="UnpackModelMatrix" type="mat4" count="1"/>
            <parameter name="LightColorMatrix" type="mat4" count="1"/>
            <parameter name="MinUVRange" type="vec4" count="1"/>
            <parameter name="MaxUVRange" type="vec4" count="1"/>
            <parameter name="LightDotUnpack" type="vec4" count="1"/>
            <parameter name="TexParam" type="vec4"   count="1"/>
            <parameter name="BoundayBox" type="vec4"   count="1"/>

        </shaderParameter>
        <shader name="vs_RSShadowMapGen" type="vertex_shader" input="FVFXyzwTex" language="glsl">
            <![CDATA[

                uniform mat4 UnpackModelViewProjectionMatrix;
                uniform mat4 UnpackModelMatrix;
                uniform mat4 LightColorMatrix;
                uniform vec4 MinUVRange;
                uniform vec4 MaxUVRange;
                uniform vec4 LightDotUnpack;
                uniform vec4 TexParam;
                uniform vec4 BoundayBox;

                attribute vec4 position;
                attribute vec2 texcoord;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;
                varying vec4 unpackPosition;

                vec3 uKeyLightDir = vec3(-0.5, 0.5, -0.70710677);
                vec3 uBackLightDir = vec3(0.5, -0.5, 0.70710677);
                vec3 uFillLightDir = vec3(0.0, 0.0, -1.0);

                void main()
                {
                    unpackPosition = UnpackModelMatrix * vec4(position.xyz, 1.0);
                    //vec3 normal = vec3(fract(position.w * LightDotUnpack.xyz * 2.0)) - vec3(1.0,1.0,1.0);
                    //vec4 lightResult;
                    //lightResult.x = max(dot(normal, uKeyLightDir), 0.0);
                    //lightResult.y = max(dot(normal, uBackLightDir), 0.0);
                    //lightResult.z = max(dot(normal, uFillLightDir), 0.0);
                    //lightResult.w = 1.0;
                    //lightColor = vec4((LightColorMatrix * lightResult).xyz,1.0);
                    lightColor = LightColorMatrix * vec4(fract(position.w * LightDotUnpack.xyz), 1.0);
                    gl_Position = UnpackModelViewProjectionMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = mix(MinUVRange.xy, MaxUVRange.xy, texcoord);
                    vec4 positionUnpack = UnpackModelMatrix * vec4(position.xyz, 1.0);
                    outTexcoord = outTexcoord - vec2(0.0,0.01);
                    outTexcoord2 = vec2(positionUnpack.x - BoundayBox.x, positionUnpack.y-BoundayBox.y);
                    outTexcoord2 = outTexcoord2 * vec2(1.0/(BoundayBox.z-BoundayBox.x), 1.0/(BoundayBox.w-BoundayBox.y));
                    outTexcoord2 = outTexcoord2*TexParam.xy + vec2(0.5, positionUnpack.z/(BoundayBox.y-BoundayBox.x))*TexParam.zw;
                }
            ]]>
        </shader>
         <shaderParameter name="ps_RSShadowMapGen">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <!-- <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/> -->
        </shaderParameter>
        <shader name="ps_RSShadowMapGen" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                //uniform sampler2D texSampler2;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;
                varying vec4 unpackPosition;

                void main()
                {
                    if( unpackPosition.z < -1.0 ) {
                        discard;
                    }
                    vec4 clr2 = texture2D(texSampler, outTexcoord);
                    vec4 clr = vec4(0.1, 0.1, 0.1, clr2.a) * lightColor;
                    //vec4 clr = vec4(1.0, 1.0, 1.0, clr2.a) * lightColor;
                    gl_FragColor = clr;
                }

            ]]>
        </shader>
        <shaderParameter name="ps_RSGlowMapGen">
            <parameter name="texSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
            <!-- <parameter name="texSampler2" type="texture2d" index="1" sampler="samplerTerrainClamp"/> -->
        </shaderParameter>
        <shader name="ps_RSGlowMapGen" type="pixel_shader" language="glsl">
            <![CDATA[
                precision mediump float;

                uniform sampler2D texSampler;
                //uniform sampler2D texSampler2;

                varying vec2 outTexcoord;
                varying vec2 outTexcoord2;
                varying vec4 lightColor;
                varying vec4 unpackPosition;

                void main()
                {
                    if( unpackPosition.z < -1.0 ) {
                        discard;
                    }
                    vec4 clr2 = texture2D(texSampler, outTexcoord);
                    //vec4 clr = vec4(0.3, 0.1, 0.1, clr2.a) * lightColor;
                    vec4 clr = vec4(1.0, 1.0, 1.0, clr2.a) * lightColor;
                    gl_FragColor = clr;
                }

            ]]>
        </shader>


        <!--blurShadowMap Shader-->
        <shaderParameter name="vs_blurShadowMap">
        </shaderParameter>
        <shader name="vs_blurShadowMap" type="vertex_shader" input="FVFXyz" language="glsl">
            <![CDATA[
              precision mediump float;
              attribute vec2 position;
              varying vec2 vUv;

              void main()
              {
                  gl_Position = vec4(position.x * 2.0 - 1.0, position.y * 2.0 - 1.0, 0.0, 1.0);
                  vUv = position.xy;
              }
       ]]>
        </shader>

         <shaderParameter name="ps_blurShadowMap">
            <parameter name="uBlurParam" type="vec4" count="1"/>
            <parameter name="uTextureDimension" type="vec4"   count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_blurShadowMap" type="pixel_shader" language="glsl">
            <![CDATA[
                precision highp float;
                uniform vec4 uBlurParam;
                uniform vec4 uTextureDimension;
                uniform sampler2D uSampler;
                varying vec2 vUv;
                vec4 blur(int diameter, sampler2D sampler, vec2 texCoord, float width, float height){
                    const float PI = 3.14159265;
                    const int maxBlur = 41;
                    if(mod(float(diameter), 2.0) == 0.0){
                        diameter++;
                    }
                    if(diameter > maxBlur){
                        diameter = maxBlur;
                    }
                    int center = (diameter - 1) / 2;

                    float sita = pow(float(diameter) / 6.0, 2.0);
                    float radio = sqrt(0.5 / PI / sita);
                    float sum = 0.0;
                    vec4 sumVec4 = vec4(0.0);

                    for(int i = 0; i < maxBlur; i++) if(i<center + 1){
                        float weight =  radio * exp(-pow(float(i), 2.0) / sita / 2.0);
                        float ii = float(i);
                        if(i == 0){
                            // 
                            vec4 color = texture2D(sampler, texCoord);
                            sumVec4 += color * weight;
                            sum += weight;
                        }else{
                            // 
                            vec4 left = texture2D(sampler, vec2( texCoord.x - ii/width, texCoord.y));
                            //  
                            vec4 right = texture2D(sampler, vec2( texCoord.x + ii/width, texCoord.y));
                            sumVec4 += left * weight;
                            sumVec4 += right * weight;
                            sum += 2.0 * weight;
                        }
                    }
                    return vec4(sumVec4.r/sum, sumVec4.g/sum, sumVec4.b/sum, sumVec4.a/sum);
                }
                void main()
                {
                    gl_FragColor = blur(int(uBlurParam.x), uSampler, vUv + uTextureDimension.xy, uTextureDimension.z, uTextureDimension.w);
                }
            ]]>
        </shader>

        <shaderParameter name="ps_blurShadowMap2">
            <parameter name="uBlurParam" type="vec4" count="1"/>
            <parameter name="uTextureDimension" type="vec4" count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_blurShadowMap2" type="pixel_shader" language="glsl">
            <![CDATA[
            precision highp float;
            uniform vec4 uBlurParam;
            uniform vec4 uTextureDimension;
            uniform sampler2D uSampler;
            varying vec2 vUv;


            vec4 blur(int diameter, sampler2D sampler, vec2 texCoord, float width,float height)
            {
                const float PI = 3.14159265;
                const int maxBlur = 41;

                if(mod(float(diameter), 2.0) == 0.0){
                    diameter++;
                }
                if(diameter > maxBlur){
                    diameter = maxBlur;
                }
                int center = (diameter - 1) / 2;

                float sita = pow(float(diameter) / 6.0, 2.0);
                float radio = sqrt(0.5 / PI / sita);
                float sum = 0.0;
                vec4 sumVec4 = vec4(0.0);

                for(int i = 0; i < maxBlur; i++) if(i<center + 1){
                    float weight =  radio * exp(-pow(float(i), 2.0) / sita / 2.0);
                    float ii = float(i);
                    if(i == 0){
                        // 
                        vec4 color = texture2D(sampler, texCoord);
                        sumVec4 += color * weight;
                        sum += weight;
                    }else{
                        // 
                        vec4 left = texture2D(sampler, vec2( texCoord.x, texCoord.y - ii/height));
                        // 
                        vec4 right = texture2D(sampler, vec2( texCoord.x, texCoord.y + ii/height));
                        sumVec4 += left * weight;
                        sumVec4 += right * weight;
                        sum += 2.0 * weight;
                    }

                }
                return vec4(sumVec4.r/sum, sumVec4.g/sum, sumVec4.b/sum, sumVec4.a/sum);
            }
            void main()
            {
                gl_FragColor = blur(int(uBlurParam.x), uSampler, vUv + uTextureDimension.xy, uTextureDimension.z, uTextureDimension.w);
            }
      ]]>
        </shader>

         <shaderParameter name="ps_blurShadowMap3">
            <parameter name="uBlurParam" type="vec4" count="1"/>
            <parameter name="uTextureDimension" type="vec4" count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_blurShadowMap3" type="pixel_shader" language="glsl">
            <![CDATA[
            precision highp float;
            uniform vec4 uBlurParam;
            uniform vec4 uTextureDimension;
            uniform sampler2D uSampler;
            varying vec2 vUv;


            vec4 blur(int diameter, sampler2D sampler, vec2 texCoord, float width,float height)
            {
                const float PI = 3.14159265;
                const int maxBlur = 41;

                if(mod(float(diameter), 2.0) == 0.0){
                    diameter++;
                }
                if(diameter > maxBlur){
                    diameter = maxBlur;
                }
                int center = (diameter - 1) / 2;

                float sita = pow(float(diameter) / 6.0, 2.0);
                float radio = sqrt(0.5 / PI / sita);
                float sum = 0.0;
                vec4 sumVec4 = vec4(0.0);

                for(int i = 0; i < maxBlur; i++) if(i<center + 1){
                    float weight =  radio * exp(-pow(float(i), 2.0) / sita / 2.0);
                    float ii = float(i);
                    if(i == 0){
                        // 
                        vec4 color = texture2D(sampler, texCoord);
                        sumVec4 += color * weight;
                        sum += weight;
                    }else{
                        // 
                        vec4 left = texture2D(sampler, vec2( texCoord.x - ii/width, texCoord.y - ii/height));
                        // 
                        vec4 right = texture2D(sampler, vec2( texCoord.x + ii/width, texCoord.y + ii/height));
                        sumVec4 += left * weight;
                        sumVec4 += right * weight;
                        sum += 2.0 * weight;
                    }

                }
                return vec4(sumVec4.r/sum, sumVec4.g/sum, sumVec4.b/sum, sumVec4.a/sum);
            }
            void main()
            {
                gl_FragColor = blur(int(uBlurParam.x), uSampler, vUv + uTextureDimension.xy, uTextureDimension.z, uTextureDimension.w);
            }
      ]]>
        </shader>

         <shaderParameter name="ps_blurShadowMap4">
            <parameter name="uBlurParam" type="vec4" count="1"/>
            <parameter name="uTextureDimension" type="vec4" count="1"/>
            <parameter name="uSampler" type="texture2d" index="0" sampler="samplerTerrainClamp"/>
        </shaderParameter>
        <shader name="ps_blurShadowMap4" type="pixel_shader" language="glsl">
            <![CDATA[
            precision highp float;
            uniform vec4 uBlurParam;
            uniform vec4 uTextureDimension;
            uniform sampler2D uSampler;
            varying vec2 vUv;


            vec4 blur(int diameter, sampler2D sampler, vec2 texCoord, float width,float height)
            {
                const float PI = 3.14159265;
                const int maxBlur = 41;

                if(mod(float(diameter), 2.0) == 0.0){
                    diameter++;
                }
                if(diameter > maxBlur){
                    diameter = maxBlur;
                }
                int center = (diameter - 1) / 2;

                float sita = pow(float(diameter) / 6.0, 2.0);
                float radio = sqrt(0.5 / PI / sita);
                float sum = 0.0;
                vec4 sumVec4 = vec4(0.0);

                for(int i = 0; i < maxBlur; i++) if(i<center + 1){
                    float weight =  radio * exp(-pow(float(i), 2.0) / sita / 2.0);
                    float ii = float(i);
                    if(i == 0){
                        // 
                        vec4 color = texture2D(sampler, texCoord);
                        sumVec4 += color * weight;
                        sum += weight;
                    }else{
                        // 
                        vec4 left = texture2D(sampler, vec2( texCoord.x - ii/width, texCoord.y + ii/height));
                        // 
                        vec4 right = texture2D(sampler, vec2( texCoord.x + ii/width, texCoord.y - ii/height));
                        sumVec4 += left * weight;
                        sumVec4 += right * weight;
                        sum += 2.0 * weight;
                    }

                }
                return vec4(sumVec4.r/sum, sumVec4.g/sum, sumVec4.b/sum, sumVec4.a/sum);
            }
            void main()
            {
                gl_FragColor = blur(int(uBlurParam.x), uSampler, vUv + uTextureDimension.xy, uTextureDimension.z, uTextureDimension.w);
            }
      ]]>
        </shader>

        <!--Technique-->
        <!--Universe Technique(T0)-->
        <technique name="OpaqueDepth_Universe">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_universe"/>
                <state name="pixel_shader" value="ps_universe"/>
            </pass>
        </technique>


        <!--Technique-->
        <!--Canvas Technique(T1)-->
        <technique name="OpaqueDepth_Canvas">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_canvas"/>
                <state name="pixel_shader" value="ps_canvas"/>
            </pass>
        </technique>

        <!--SkyFromAtmosphere Technique(T2)-->
        <technique name="OpaqueDepth_SkyFromAtmosphere">
            <pass name="p0">
                <state name="cull_mode" value="none"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="vertex_shader" value="vs_sky_atmosphere"/>
                <state name="pixel_shader" value="ps_sky_atmosphere"/>
            </pass>
        </technique>

        <!--SkyFromSpace Technique(T3)-->
        <technique name="OpaqueDepth_SkyFromSpace">
            <pass name="p0">
                <state name="cull_mode" value="front"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="vertex_shader" value="vs_sky_space"/>
                <state name="pixel_shader" value="ps_sky_space"/>
            </pass>
        </technique>

        <!--Terrain Technique(T4)-->
        <technique name="OpaqueDepth_Terrain">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_1"/>
            </pass>
        </technique>

        <!--Terrain Technique(T5)-->
        <technique name="OpaqueDepth_Model">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_model"/>
                <state name="pixel_shader" value="ps_model"/>
            </pass>
        </technique>

        <!--Terrain Technique(T6)-->
        <technique name="OpaqueDepth_Polyline">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_polyline"/>
                <state name="pixel_shader" value="ps_polyline"/>
            </pass>
        </technique>

        <!--Terrain Technique(T7)-->
        <technique name="OpaqueDepth_Polyline2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_polyline2"/>
                <state name="pixel_shader" value="ps_polyline2"/>
            </pass>
        </technique>

        <!--Reproject Technique(T8)-->
        <technique name="OpaqueDepth_Reproject">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="one"/>
                <state name="dest_blend" value="zero"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_reprojectMercator"/>
                <state name="pixel_shader" value="ps_reprojectMercator"/>
            </pass>
        </technique>

        <!--Terrain Technique(T9)-->
        <technique name="OpaqueDepth_Terrain2">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_2"/>
            </pass>
        </technique>
        <!--Terrain Technique(T10)-->
        <technique name="OpaqueDepth_Terrain3">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_3"/>
            </pass>
        </technique>

        <!--Terrain Technique(T11)-->
        <technique name="OpaqueDepth_Terrain4">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_4"/>
            </pass>
        </technique>
        <!--Terrain Technique(T12)-->
        <technique name="OpaqueDepth_Terrain5">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_5"/>
            </pass>
        </technique>
        <!--Terrain Technique(T13)-->
        <technique name="OpaqueDepth_Terrain6">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_6"/>
            </pass>
        </technique>
        <!--Terrain Technique(T14)-->
        <technique name="OpaqueDepth_Terrain7">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_7"/>
            </pass>
        </technique>
        <!--Terrain Technique(T15)-->
        <technique name="OpaqueDepth_Terrain8">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_terrain"/>
                <state name="pixel_shader" value="ps_terrain_8"/>
            </pass>
        </technique>
        <!--Terrain Technique(T16)-->
        <technique name="OpaqueDepth_Model2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_model2"/>
                <state name="pixel_shader" value="ps_model2"/>
            </pass>
        </technique>
        <!--Terrain Technique(T17)-->
        <technique name="OpaqueDepth_Model3">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_model3"/>
                <state name="pixel_shader" value="ps_model2"/>
            </pass>
        </technique>


        <!--Terrain Technique(T18)-->
        <technique name="OpaqueDepth_RecceModel">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <!-- <state name="src_blend" value="one"/>
                <state name="dest_blend" value="zero"/> -->
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_recceModel"/>
                <state name="pixel_shader" value="ps_recceModel"/>
            </pass>
        </technique>

        <!--Terrain Technique(T19)-->
        <technique name="OpaqueDepth_RecceModel_Shadow">
            <pass name="p0">
                <!--<state name="cull_mode"                 value="none"/>-->
                <!--<state name="depth_enable"              value="true"/>-->
                <!--<state name="depth_write_mask"          value="0"/>-->
                <!--<state name="color_write_mask"          value="0"/>-->
                <!--<state name="stencil_enable"            value="true"/>-->
                <!--<state name="two_sided_stencil_enable"  value="true"/>-->
                <!--<state name="stencil_func"              value="always"/>-->
                <!--<state name="ccw_stencil_func"          value="always"/>-->
                <!--<state name="ccw_stencil_pass_op"       value="incr"/>-->
                <!--<state name="stencil_pass_op"           value="decr"/>-->
                <state name="vertex_shader" value="vs_recceModelShadow"/>
                <state name="pixel_shader" value="ps_recceModelShadow"/>
            </pass>
        </technique>
        <!--Terrain Technique(T20)-->
        <technique name="OpaqueDepth_ShadowVolumeFill">
            <pass name="p0">
                <!--<state name="blend_enable" value="false"/>-->
                <!--<state name="src_blend" value="src_alpha"/>-->
                <!--<state name="dest_blend" value="inv_src_alpha"/>-->
                <!--<state name="depth_enable" value="true"/>-->
                <!--<state name="depth_write_mask" value="1"/>-->
                <!--<state name="cull_mode" value="none"/>-->
                <state name="vertex_shader" value="vs_shadowVolumeFill"/>
                <state name="pixel_shader" value="ps_shadowVolumeFill"/>
            </pass>
        </technique>

        <!--Terrain Technique(T21)-->
        <technique name="OpaqueDepth_RecceModelWater">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_recceModelWater"/>
                <state name="pixel_shader" value="ps_recceModelWater"/>
            </pass>
        </technique>

        <!--Terrain Technique(T22)-->
        <technique name="OpaqueDepth_RecceGround">
            <pass name="p0">
                <state name="blend_enable" value="false"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_recceGround"/>
                <state name="pixel_shader" value="ps_recceGround"/>
            </pass>
        </technique>

        <!--Terrain Technique(T23)-->
        <technique name="OpaqueDepth_Model_normal">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_json_model_normal"/>
                <state name="pixel_shader" value="ps_json_model_normal"/>
            </pass>
        </technique>

        <!--Terrain Technique(T24)-->
        <technique name="OpaqueDepth_Polyline">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_polyline"/>
                <state name="pixel_shader" value="ps_polyline"/>
            </pass>
        </technique>

        <!--Terrain Technique(T25)-->
        <technique name="OpaqueDepth_Polyline2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_polyline2"/>
                <state name="pixel_shader" value="ps_polyline2"/>
            </pass>
        </technique>
        <!--Terrain Technique(T26)-->
        <technique name="OpaqueDepth_RecceModel_Shadow2">
            <pass name="p0">
                <!--<state name="cull_mode"                 value="none"/>-->
                <!--<state name="depth_enable"              value="true"/>-->
                <!--<state name="depth_write_mask"          value="0"/>-->
                <!--<state name="color_write_mask"          value="0"/>-->
                <!--<state name="stencil_enable"            value="true"/>-->
                <!--<state name="two_sided_stencil_enable"  value="true"/>-->
                <!--<state name="stencil_func"              value="always"/>-->
                <!--<state name="ccw_stencil_func"          value="always"/>-->
                <!--<state name="ccw_stencil_pass_op"       value="incr"/>-->
                <!--<state name="stencil_pass_op"           value="decr"/>-->
                <state name="vertex_shader" value="vs_recceModelShadow2"/>
                <state name="pixel_shader" value="ps_recceModelShadow"/>
            </pass>
        </technique>

        <!--Terrain Technique(T27)-->
        <technique name="OpaqueDepth_Flake_line">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_flake_line"/>
                <state name="pixel_shader" value="ps_flake_line"/>
            </pass>
        </technique>
        <!--Terrain Technique(T28)-->
        <technique name="OpaqueDepth_Model4">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_model4"/>
                <state name="pixel_shader" value="ps_model4"/>
            </pass>
        </technique>
        <!--Terrain Technique(T29)-->
        <technique name="OpaqueDepth_Polygon">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_polygon"/>
                <state name="pixel_shader" value="ps_polygon"/>
            </pass>
        </technique>
        <!--Terrain Technique(T30)-->
        <technique name="OpaqueDepth_Polygon2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_polygon"/>
                <state name="pixel_shader" value="ps_polygon"/>
            </pass>
        </technique>
        <!--Terrain Technique(T31)-->
        <technique name="OpaqueDepth_RecceModel_Transparency">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="src_blend_alpha" value="zero"/>
                <state name="dest_blend_alpha" value="one"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_recceModel"/>
                <state name="pixel_shader" value="ps_recceModel_Transparency"/>
            </pass>
        </technique>
        <!--Terrain Technique(T32)-->
        <technique name="OpaqueDepth_Textured_Polyline">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_textured_polyline"/>
                <state name="pixel_shader" value="ps_polygon"/>
            </pass>
        </technique>

        <!--Terrain Technique(T33)-->
        <technique name="OpaqueDepth_Textured_Polyline2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_polyline"/>
                <state name="pixel_shader" value="ps_polygon"/>
            </pass>
        </technique>

        <!--Terrain Technique(T34)-->
        <technique name="OpaqueDepth_Volume_Polyline">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_volume_polyline"/>
                <state name="pixel_shader" value="ps_polyline3"/>
            </pass>
        </technique>

        <!--Terrain Technique(T35)-->
        <technique name="OpaqueDepth_Compass">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <!--<state name="depth_write_mask" value="1"/>-->
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_compass"/>
                <state name="pixel_shader" value="ps_compass"/>
            </pass>
        </technique>
        <!--Terrain Technique(T36)-->
        <technique name="OpaqueDepth_RSModelCommon">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_RSModelCommon"/>
                <state name="pixel_shader" value="ps_RSModelCommon"/>
            </pass>
        </technique>

        <!--Terrain Technique(T37)-->
<!--         <technique name="OpaqueDepth_FontRenderWisthBlur">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_canvas"/>
                <state name="pixel_shader" value="ps_canvas"/>
            </pass>
        </technique> -->
        <technique name="OpaqueDepth_FontRenderWithBlur">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_text_with_blur"/>
                <state name="pixel_shader" value="ps_text_with_blur"/>
            </pass>
        </technique>
        <!--Terrain Technique(T38)-->
        <technique name="OpaqueDepth_RSShadowMapGen">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_RSShadowMapGen"/>
                <state name="pixel_shader" value="ps_RSShadowMapGen"/>
            </pass>
        </technique>
        <!--Blur ShadowMap Technique(T39)-->
        <technique name="OpaqueDepth_blurShadowMap">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="one"/>
                <state name="dest_blend" value="zero"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_blurShadowMap"/>
                <state name="pixel_shader" value="ps_blurShadowMap"/>
            </pass>
        </technique>

        <!--Blur ShadowMap2 Technique(T40)-->
        <technique name="OpaqueDepth_blurShadowMap2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="one"/>
                <state name="dest_blend" value="zero"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_blurShadowMap"/>
                <state name="pixel_shader" value="ps_blurShadowMap2"/>
            </pass>
        </technique>

        
        <!--Textured Volume Technique(T41)-->
        <technique name="OpaqueDepth_TexturedVolume">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume"/>
                <state name="pixel_shader" value="ps_textured_volume"/>
            </pass>
        </technique>




        <!--Textured Volume With ShadowMap Technique(T42)-->
        <technique name="OpaqueDepth_TexturedVolumeShadow">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume_shadow_map"/>
                <state name="pixel_shader" value="ps_textured_volume_shadow_map"/>
            </pass>
        </technique>

        <!--Textured Volume With ShadowMap Technique(T43)-->
        <technique name="OpaqueDepth_TexturedVolumeShadowGen">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume"/>
                <state name="pixel_shader" value="ps_textured_volume_shadow_map_gen"/>
            </pass>
        </technique>
        
        <!--Textured Volume With ShadowMap Technique(T44)-->
        <technique name="OpaqueDepth_VolumePolygonOutline">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume"/>
                <state name="pixel_shader" value="ps_textured_volume"/>
            </pass>
        </technique>

        <!--Terrain Technique(T45)-->
        <technique name="OpaqueDepth_RSModelWithGlow">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_RSModelWithGlow"/>
                <state name="pixel_shader" value="ps_RSModelWithGlow"/>
            </pass>
        </technique>
        <!--Terrain Technique(T46)-->
        <technique name="OpaqueDepth_RSGlowMapGen">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_RSShadowMapGen"/>
                <state name="pixel_shader" value="ps_RSGlowMapGen"/>
            </pass>
        </technique>
        <!--Terrain Technique(T47)-->
        <technique name="OpaqueDepth_RSWallWithGlow">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_RSWallWithGlow"/>
                <state name="pixel_shader" value="ps_RSWallWithGlow"/>
            </pass>
        </technique>

        <!--Textured Volume Technique(T48)-->
        <technique name="OpaqueDepth_TexturedVolume2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume2"/>
                <state name="pixel_shader" value="ps_textured_volume2"/>
            </pass>
        </technique>

        <!--Blur ShadowMap3 Technique(T49)-->
        <technique name="OpaqueDepth_blurShadowMap">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="one"/>
                <state name="dest_blend" value="zero"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_blurShadowMap"/>
                <state name="pixel_shader" value="ps_blurShadowMap3"/>
            </pass>
        </technique>

        <!--Blur ShadowMap4 Technique(T50)-->
        <technique name="OpaqueDepth_blurShadowMap2">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="one"/>
                <state name="dest_blend" value="zero"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_blurShadowMap"/>
                <state name="pixel_shader" value="ps_blurShadowMap4"/>
            </pass>
        </technique>

        <!--Gltf Model Opaque Technique(T51)-->
        <technique name="OpaqueDepth_GltfModelOpaque">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_gltf_model"/>
                <state name="pixel_shader" value="ps_gltf_model"/>
            </pass>
        </technique>

        <!--Gltf Model Transparency Technique(T52)-->
        <technique name="OpaqueDepth_GltfModelTransparency">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="none"/>
                <state name="vertex_shader" value="vs_gltf_model"/>
                <state name="pixel_shader" value="ps_gltf_model_transparency"/>
            </pass>
        </technique>

        <!--Gltf Model Shadow Technique(T53)-->
        <technique name="OpaqueDepth_GltfModelShadow">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_gltf_model"/>
                <state name="pixel_shader" value="ps_textured_volume_shadow_map_gen"/>
            </pass>
        </technique>

        <!--OpaqueDepth_RSModelCommon_Transparency Technique(T54)-->
        <technique name="OpaqueDepth_RSModelCommon_Transparency">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="0"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_RSModelCommon"/>
                <state name="pixel_shader" value="ps_RSModelCommon_Transparency"/>
            </pass>
        </technique>
        
         <!--OpaqueDepth RSModelCommon Blend Technique(T55)-->
        <technique name="OpaqueDepth_RSModelCommon_Blend">
            <pass name="p0">
       <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="front"/>
                <state name="vertex_shader" value="vs_RSModelCommon"/>
                <state name="pixel_shader" value="ps_RSModelCommon_Blend"/>
            </pass>
        </technique>

        <!--OpaqueDepth RecceModel Blend Technique(T56)-->
        <technique name="OpaqueDepth_RecceModel_Blend">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <!-- <state name="src_blend" value="one"/> -->
                <!-- <state name="dest_blend" value="one"/> -->
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_recceModel"/>
                <state name="pixel_shader" value="ps_recceModel_Blend"/>
            </pass>
        </technique>


        <!--Textured Volume With ShadowMap Technique(T42)-->
        <!-- <technique name="OpaqueDepth_TexturedVolumeWithShadow">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume_shadow_map"/>
                <state name="pixel_shader" value="ps_textured_volume_shadow_map"/>
            </pass>
        </technique> -->

        <!--Textured Volume With ShadowMap Technique(T43)-->
        <!-- <technique name="OpaqueDepth_TexturedVolumeShadowGen">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="true"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume"/>
                <state name="pixel_shader" value="ps_textured_volume_shadow_map_gen"/>
            </pass>
        </technique> -->
        
        <!--Textured Volume With ShadowMap Technique(T44)-->
        <!-- <technique name="OpaqueDepth_VolumePolygonOutline">
            <pass name="p0">
                <state name="blend_enable" value="true"/>
                <state name="src_blend" value="src_alpha"/>
                <state name="dest_blend" value="inv_src_alpha"/>
                <state name="depth_enable" value="false"/>
                <state name="depth_write_mask" value="1"/>
                <state name="cull_mode" value="back"/>
                <state name="vertex_shader" value="vs_textured_volume"/>
                <state name="pixel_shader" value="ps_textured_volume"/>
            </pass>
        </technique> -->

    </effect>
</Xml>
